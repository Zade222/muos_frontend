/* This file is autogenerated by cbindgen. Do not edit it directly. */

#if defined(__GNUC__) || defined(__clang__)
#  define SPRITE_SHRINK_MUST_USE __attribute__((warn_unused_result))
#elif defined(_MSC_VER)
#  define SPRITE_SHRINK_MUST_USE _Check_return_
#else
#  define SPRITE_SHRINK_MUST_USE
#endif


#ifndef FFI_LIB_SPRITE_SHRINK_H
#define FFI_LIB_SPRITE_SHRINK_H

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

typedef enum FFICallbackStatus {
  CallbackOk = 0,
  Error = -1,
  Cancelled = -2,
} FFICallbackStatus;

/**
 * FFI-safe enum representing the different stages of a long-running
 * operation.
 *
 * This enum is used within the [`FFIProgress`] struct to signal which phase
 * of the archive-building process is currently active.
 */
enum {
  GeneratingDictionary = 0,
  DictionaryDone = 1,
  Compressing = 2,
  ChunkCompressed = 3,
  Finalizing = 4,
};
typedef uint8_t FFIProgressType;

/**
 * Represents the status of an FFI operation.
 */
typedef enum FFIStatus {
  StatusOk = 0,
  NullArgument = -1,
  InvalidHeader = -2,
  UnsupportedVersion = -3,
  ManifestDecodeError = -4,
  InternalError = -5,
  DictionaryError = -6,
  CompressionError = -7,
  ThreadPoolError = -8,
  VerificationHashMismatch = -9,
  VerificationMissingChunk = -10,
  InvalidString = -11,
  SerializationMissingChunk = -12,
  InvalidMagicNumber = -13,
  SeekOutOfBounds = -14,
  IncorrectArrayLength = -15,
  NoDataToProcess = -16,
  BufferTooSmall = -17,
  HashNotFound = -18,
} FFIStatus;

/**
 * Arguments required to verify a single file using the verify_single_file_u64
 * function.
 *
 * This struct is passed by pointer to the `verify_single_file_u64` FFI entry
 * point. All pointers must be valid for the duration of the call; the parent
 * application will not take ownership of any of the data.
 *
 * # Fields
 *
 * * `file_manifest_parent` – Pointer to an `FFIFileManifestParentU64` that
 *   describes the file manifest (filename and related chunk metadata). Must
 *   be non‑null and point to a properly‑initialized struct that lives at
 *   least until the verification completes.
 * * `veri_hash_array_ptr` – Pointer to a byte buffer that contains the
 *   expected verification hashes for the file. The buffer must be a length of
 *   64 (64 x 8 bytes).
 * * `user_data` – Opaque pointer passed unchanged to the callback functions.
 *   It can be used by the caller to store context (e.g., a Rust
 *   `Arc<Mutex<…>>` or a raw pointer to a C struct). The parent application
 *   never dereferences this pointer; it is only handed back to the callbacks.
 * * `get_chunks_cb` – Callback invoked by the verifier when it needs to
 *   retrieve the raw chunk data for a set of hash values.
 *   It must return an `FFIChunkDataArray` describing a contiguous buffer that
 *   contains the requested chunk data. The returned buffer is owned by the
 *   caller and must remain valid until the next callback invocation.
 *   The callback receives:
 *   - `user_data`: the same pointer passed in this struct,
 *   - `hashes`: pointer to an array of `u128` hash identifiers,
 *   - `hashes_len`: length of the `hashes` array.
 * * `progress_cb` – Optional progress callback. It is called periodically
 *   with the number of bytes processed so far.
 *
 * # Safety
 *
 * This struct is used across the FFI boundary, so all pointers must be
 * correctly aligned and point to memory that lives long enough. Supplying
 * a dangling or incorrectly sized pointer results in undefined behaviour. The
 * callbacks themselves must also obey the FFI safety contract: they may not
 * unwind across the FFI boundary and must not dereference any pointers other
 * than those provided to them.
 */
typedef struct VerifySingleFileArgsU64 VerifySingleFileArgsU64;

typedef enum FFIStatus FFIResult;

/**
 * FFI-safe equivalent of `SSAChunkMeta`, containing the metadata for a single
 * chunk within a file's manifest.
 *
 * This struct holds the essential information needed to identify and
 * correctly place a data chunk during file reconstruction. An array of these
 * structs, sorted by `offset`, forms a key part of the
 * `FFIFileManifestParent`.
 *
 * # Type Parameters
 *
 * * `H`: The generic hash type (e.g., `u64`, `u128`) used to uniquely
 *   identify the chunk's content.
 *
 * # Fields
 *
 * * `hash`: The unique deduplication hash of the chunk's data. This is used
 *   to look up the chunk's compressed data in the archive's chunk index.
 * * `offset`: The starting byte position of this chunk within the original,
 *   uncompressed file.
 * * `length`: The size of the chunk in bytes in its original, uncompressed
 *   form.
 */
typedef struct FFISSAChunkMeta_u64 {
  uint64_t hash;
  uint64_t offset;
  uint32_t length;
} FFISSAChunkMeta_u64;

/**
 * FFI-safe equivalent of `FileManifestParent`, describing a single file's
 * metadata within an archive.
 *
 * This struct holds all the necessary information to reconstruct a file from
 * its constituent chunks. It contains the filename and a sorted list of chunk
 * metadata, which allows the extraction logic to retrieve and assemble the
 * file's data in the correct order. An array of these structs forms the
 * complete file manifest.
 *
 * # Type Parameters
 *
 * * `H`: The generic hash type (e.g., `u64`, `u128`) used in the chunk
 *   metadata.
 *
 * # Fields
 *
 * * `filename`: A pointer to a null-terminated C string representing the
 *   original name of the file.
 * * `chunk_metadata`: A pointer to a contiguous array of [`FFISSAChunkMeta`]
 *   structs. This array is sorted by the chunk's original offset, ensuring
 *   correct file reconstruction.
 * * `chunk_metadata_len`: The total number of `FFISSAChunkMeta` structs in
 *   the `chunk_metadata` array.
 *
 * # Safety
 *
 * When this struct is created by Rust and passed to C, the C caller takes
 * ownership of the memory pointed to by `filename` and `chunk_metadata`.
 * This memory must be deallocated by calling the appropriate free function
 * (e.g., `free_parsed_manifest_*` or
 * `free_file_manifest_and_chunks_*`) to prevent memory leaks.
 */
typedef struct FFIFileManifestParent_u64 {
  char *filename;
  const struct FFISSAChunkMeta_u64 *chunk_metadata;
  uintptr_t chunk_metadata_len;
  uintptr_t chunk_metadata_cap;
} FFIFileManifestParent_u64;

/**
 * An `FFIFileManifestParent` specialized for `u64` hashes.
 *
 * This type is used in FFI functions that deal with file manifests where the
 * chunk hash algorithm produces a 64-bit integer.
 */
typedef struct FFIFileManifestParent_u64 FFIFileManifestParentU64;

/**
 * Represents a C-compatible, heap-allocated byte vector.
 *
 * This struct is used to pass ownership of a dynamically sized byte array
 * from C to Rust. It is a fundamental building block for more complex data
 * structures, such as `FFIChunkDataArray`, which represents an array of these
 * byte vectors.
 *
 * # Fields
 *
 * * `ptr`: A raw pointer to the beginning of the heap-allocated byte array.
 * * `len`: The number of bytes in the array pointed to by `ptr`.
 *
 * # Memory Management
 *
 * The memory management contract for this struct is context-dependent,
 * as it is used in different patterns across the FFI layer.
 *
 * 1.  **Rust Takes Ownership**: In some functions (e.g., serialization),
 *     the C caller allocates memory for this struct and its contents, and
 *     Rust takes ownership, freeing the memory when it's done.
 * 2.  Caller Retains Ownership: In other functions (e.g.,
 *     archive building), the C caller allocates the memory and also remains
 *     responsible for freeing it, usually via a dedicated `free_...`
 *     callback provided to Rust.
 *
 * **Warning:** Always refer to the documentation of the specific FFI
 * function you are calling to understand the correct memory management
 * policy. Assuming the wrong model will lead to memory leaks or
 * double-free errors.
 */
typedef struct FFIVecBytes {
  uint8_t *ptr;
  uintptr_t len;
  uintptr_t cap;
} FFIVecBytes;

/**
 * Represents an array of byte vectors, used to pass multiple chunks of data
 * across the FFI boundary.
 *
 * This struct is primarily used as the return type for C callback functions
 * that provide raw chunk data to Rust. For example, the `ArchiveBuilder`
 * uses it to retrieve uncompressed chunk data from the C application during
 * the archive creation process.
 *
 * # Fields
 *
 * * `ptr`: A pointer to the beginning of a contiguous array of
 *   [`FFIVecBytes`] structs. Each struct in this array represents one chunk's
 *   data.
 * * `len`: The number of [`FFIVecBytes`] structs in the array pointed to by
 *   `ptr`.
 *
 * # Memory Management
 *
 * The memory management contract for this struct is context-dependent,
 * as it is used in different patterns across the FFI layer.
 *
 * 1.  Rust Takes Ownership: In some functions (e.g., serialization),
 *     the C caller allocates memory for this struct and its contents, and
 *     Rust takes ownership, freeing the memory when it's done.
 * 2.  Caller Retains Ownership: In other functions (e.g., archive
 *     building), the C caller allocates the memory and also remains
 *     responsible for freeing it, usually via a dedicated `free_...`
 *     callback provided to Rust.
 *
 * **Warning:** Always refer to the documentation of the specific FFI
 * function you are calling to understand the correct memory management
 * policy. Assuming the wrong model will lead to memory leaks or
 * double-free errors.
 */
typedef struct FFIChunkDataArray {
  struct FFIVecBytes *ptr;
  uintptr_t len;
  uintptr_t cap;
} FFIChunkDataArray;

/**
 * Bundles all parameters for creating a new `ArchiveBuilder` with `u64`
 * hashes.
 *
 * This struct is passed by pointer to `archive_builder_new_u64` to provide
 * all the necessary data for initializing the archive creation process,
 * including file metadata, chunk hashes, and C callbacks for data handling.
 *
 * # Fields
 *
 * * `manifest_array_ptr`: Pointer to an array of [`FFIFileManifestParentU64`]
 *   struct entries.
 * * `manifest_len`: The number of elements in the `manifest_array_ptr` array.
 * * `sorted_hashes_array_ptr`: Pointer to a sorted array of all unique `u64`
 *   chunk hashes.
 * * `sorted_hashes_len`: The number of elements in the
 *   `sorted_hashes_array_ptr` array.
 * * `file_count`: The total number of files being added to the archive.
 * * `total_size`: The total combined size, in bytes, of all unique
 *   uncompressed chunks.
 * * `user_data`: An opaque `void` pointer passed back to the C callbacks,
 *   allowing the C side to maintain state.
 * * `get_chunks_cb`: A C function pointer that the builder calls to request
 *   raw data for a set of hashes.
 * * `free_chunks_cb`: A C function pointer to free the data array returned by
 *   `get_chunks_cb`.
 * * `write_comp_data_cb`: A C function pointer that the builder calls to
 *   write out the compressed archive data.
 *
 * # Safety
 *
 * The C caller is responsible for ensuring that all pointers within this
 * struct are non-null and point to valid memory for the duration of the
 * `archive_builder_new_u64` call. The `user_data` and callback function
 * pointers must remain valid for the entire lifetime of the `ArchiveBuilder`
 * that is created.
 */
typedef struct ArchiveBuilderArgsU64 {
  const FFIFileManifestParentU64 *manifest_array_ptr;
  uintptr_t manifest_len;
  const uint64_t *sorted_hashes_array_ptr;
  uintptr_t sorted_hashes_len;
  uint32_t file_count;
  uint64_t total_size;
  void *user_data;
  enum FFICallbackStatus (*get_chunks_cb)(void *user_data,
                                          const uint64_t *hashes,
                                          uintptr_t hashes_len,
                                          struct FFIChunkDataArray *out_chunks);
  void (*free_chunks_cb)(void *user_data, struct FFIChunkDataArray chunks);
  enum FFICallbackStatus (*write_comp_data_cb)(void *user_data,
                                               const uint8_t *data,
                                               uintptr_t data_len,
                                               bool is_flush);
} ArchiveBuilderArgsU64;

/**
 * An opaque FFI handle to the `ArchiveBuilder`, configured for `u64` hashes.
 *
 * This struct acts as a pointer to a Rust `ArchiveBuilder` instance without
 * exposing its internal layout to C. It allows C code to create, configure,
 * and ultimately build a sprite-shrink archive in a memory-safe way.
 *
 * # Lifecycle
 *
 * 1.  An instance of this handle is created and returned by
 *     [`archive_builder_new_u64`].
 * 2.  The C caller can then use the handle with various
 *     `archive_builder_set_*_u64` functions to configure the archive's
 *     parameters (e.g., compression level, dictionary size).
 * 3.  Finally, the handle must be passed to [`archive_builder_build_u64`],
 *     which consumes the builder, produces the final archive data, and
 *     deallocates the underlying Rust object.
 * 4.  If the archive creation process is aborted before calling `build`, the
 *     handle **must** be passed to [`archive_builder_free_u64`] to prevent
 *     a memory leak.
 *
 * # Safety
 *
 * The C caller owns the pointer to this handle. It is the caller's
 * responsibility to ensure that the handle is used correctly and that its
 * memory is eventually freed by calling either the `build` or `free`
 * function exactly once. Failure to do so will result in memory leaks or
 * undefined behavior.
 */
typedef struct ArchiveBuilderU64 {
  uint8_t _private[0];
} ArchiveBuilderU64;

/**
 * FFI-safe wrapper for a 128-bit value represented as a byte array.
 *
 * This struct is used to ensure that 128-bit hash values have a consistent
 * and well-defined memory layout when passed across the FFI boundary.
 * `cbindgen` can generate a clean C struct for this, avoiding potential
 * issues with raw array types in generic structs.
 */
typedef struct U128Bytes {
  uint8_t bytes[16];
} U128Bytes;

/**
 * FFI-safe equivalent of `SSAChunkMeta`, containing the metadata for a single
 * chunk within a file's manifest.
 *
 * This struct holds the essential information needed to identify and
 * correctly place a data chunk during file reconstruction. An array of these
 * structs, sorted by `offset`, forms a key part of the
 * `FFIFileManifestParent`.
 *
 * # Type Parameters
 *
 * * `H`: The generic hash type (e.g., `u64`, `u128`) used to uniquely
 *   identify the chunk's content.
 *
 * # Fields
 *
 * * `hash`: The unique deduplication hash of the chunk's data. This is used
 *   to look up the chunk's compressed data in the archive's chunk index.
 * * `offset`: The starting byte position of this chunk within the original,
 *   uncompressed file.
 * * `length`: The size of the chunk in bytes in its original, uncompressed
 *   form.
 */
typedef struct FFISSAChunkMeta_U128Bytes {
  struct U128Bytes hash;
  uint64_t offset;
  uint32_t length;
} FFISSAChunkMeta_U128Bytes;

/**
 * FFI-safe equivalent of `FileManifestParent`, describing a single file's
 * metadata within an archive.
 *
 * This struct holds all the necessary information to reconstruct a file from
 * its constituent chunks. It contains the filename and a sorted list of chunk
 * metadata, which allows the extraction logic to retrieve and assemble the
 * file's data in the correct order. An array of these structs forms the
 * complete file manifest.
 *
 * # Type Parameters
 *
 * * `H`: The generic hash type (e.g., `u64`, `u128`) used in the chunk
 *   metadata.
 *
 * # Fields
 *
 * * `filename`: A pointer to a null-terminated C string representing the
 *   original name of the file.
 * * `chunk_metadata`: A pointer to a contiguous array of [`FFISSAChunkMeta`]
 *   structs. This array is sorted by the chunk's original offset, ensuring
 *   correct file reconstruction.
 * * `chunk_metadata_len`: The total number of `FFISSAChunkMeta` structs in
 *   the `chunk_metadata` array.
 *
 * # Safety
 *
 * When this struct is created by Rust and passed to C, the C caller takes
 * ownership of the memory pointed to by `filename` and `chunk_metadata`.
 * This memory must be deallocated by calling the appropriate free function
 * (e.g., `free_parsed_manifest_*` or
 * `free_file_manifest_and_chunks_*`) to prevent memory leaks.
 */
typedef struct FFIFileManifestParent_U128Bytes {
  char *filename;
  const struct FFISSAChunkMeta_U128Bytes *chunk_metadata;
  uintptr_t chunk_metadata_len;
  uintptr_t chunk_metadata_cap;
} FFIFileManifestParent_U128Bytes;

/**
 * An `FFIFileManifestParent` specialized for `u128` hashes.
 *
 * This type is used in FFI functions that deal with file manifests where the
 * chunk hash algorithm produces a 128-bit integer, represented on the FFI
 * boundary as a [u8; 16] byte array in a U128Bytes struct.
 */
typedef struct FFIFileManifestParent_U128Bytes FFIFileManifestParentU128;

/**
 * Bundles all parameters for creating a new `ArchiveBuilder` with `u128`
 * hashes.
 *
 * This struct is passed by pointer to `archive_builder_new_u128` to provide
 * all the necessary data for initializing the archive creation process,
 * including file metadata, chunk hashes, and C callbacks for data handling.
 *
 * # Fields
 *
 * * `manifest_array_ptr`: Pointer to an array of
 *   [`FFIFileManifestParentU128`]  structs.
 * * `manifest_len`: The number of elements in the `manifest_array_ptr` array.
 * * `sorted_hashes_array_ptr`: Pointer to a sorted array of all unique `u128`
 *   chunk hashes. Each element is a [u8; 16] in little-endian order.
 * * `sorted_hashes_len`: The number of hashes in the
 *   `sorted_hashes_array_ptr` array.
 * * `file_count`: The total number of files being added to the archive.
 * * `total_size`: The total combined size, in bytes, of all unique
 *   uncompressed chunks.
 * * `user_data`: An opaque `void` pointer passed back to the C callbacks,
 *   allowing the C side to maintain state.
 * * `get_chunks_cb`: A C function pointer that the builder calls to request
 *   raw data for a set of hashes.
 * * `free_chunks_cb`: A C function pointer to free the data array returned by
 *   `get_chunks_cb`.
 * * `write_comp_data_cb`: A C function pointer that the builder calls to
 *   write out the compressed archive data.
 *
 * # Safety
 *
 * The C caller is responsible for ensuring that all pointers within this
 * struct are non-null and point to valid memory for the duration of the
 * `archive_builder_new_u128` call. The `user_data` and callback function
 * pointers must remain valid for the entire lifetime of the `ArchiveBuilder`
 * that is created.
 */
typedef struct ArchiveBuilderArgsU128 {
  const FFIFileManifestParentU128 *manifest_array_ptr;
  uintptr_t manifest_len;
  const uint8_t *sorted_hashes_array_ptr;
  uintptr_t sorted_hashes_len;
  uint32_t file_count;
  uint64_t total_size;
  void *user_data;
  enum FFICallbackStatus (*get_chunks_cb)(void *user_data,
                                          const uint8_t *hashes,
                                          uintptr_t hashes_len,
                                          struct FFIChunkDataArray *out_chunks);
  void (*free_chunks_cb)(void *user_data, struct FFIChunkDataArray chunks);
  enum FFICallbackStatus (*write_comp_data_cb)(void *user_data,
                                               const uint8_t *data,
                                               uintptr_t data_len,
                                               bool is_flush);
} ArchiveBuilderArgsU128;

/**
 * An opaque FFI handle to the `ArchiveBuilder`, configured for `u128` hashes.
 *
 * This struct acts as a pointer to a Rust `ArchiveBuilder` instance without
 * exposing its internal layout to C. It allows C code to create, configure,
 * and ultimately build a sprite-shrink archive in a memory-safe way.
 *
 * # Lifecycle
 *
 * 1.  An instance of this handle is created and returned by
 *     [`archive_builder_new_u128`].
 * 2.  The C caller can then use the handle with various
 *     `archive_builder_set_*_u128` functions to configure the archive's
 *     parameters (e.g., compression level, dictionary size).
 * 3.  Finally, the handle must be passed to [`archive_builder_build_u128`],
 *     which consumes the builder, produces the final archive data, and
 *     deallocates the underlying Rust object.
 * 4.  If the archive creation process is aborted before calling `build`, the
 *     handle **must** be passed to [`archive_builder_free_u128`] to prevent
 *     a memory leak.
 *
 * # Safety
 *
 * The C caller owns the pointer to this handle. It is the caller's
 * responsibility to ensure that the handle is used correctly and that its
 * memory is eventually freed by calling either the `build` or `free`
 * function exactly once. Failure to do so will result in memory leaks or
 * undefined behavior.
 */
typedef struct ArchiveBuilderU128 {
  uint8_t _private[0];
} ArchiveBuilderU128;

/**
 * FFI-safe struct to pass progress information from Rust to a C caller.
 *
 * This struct is used by C callback functions that are registered to receive
 * updates on long-running operations, such as archive building. It provides
 * a clear, structured way to report the current state of the process.
 *
 * # Fields
 *
 * * `ty`: An [`FFIProgressType`] enum value that specifies the kind of
 *   progress being reported (e.g., dictionary generation, compression).
 * * `total_chunks`: This field is only valid when `ty` is
 *   [`FFIProgressType::Compressing`]. It indicates the total number of
 *   unique data chunks that need to be compressed, allowing the C caller to
 *   set up a progress bar or other indicator.
 */
typedef struct FFIProgress {
  FFIProgressType ty;
  /**
   * Only valid when `ty` is `Compressing`.
   */
  uint64_t total_chunks;
} FFIProgress;

/**
 * Represents a buffer containing the final, compressed archive data.
 *
 * This struct is returned by a successful build operation (e.g., from
 * `archive_builder_build_u64`). When a C caller receives a pointer to this
 * struct, it takes ownership of both the struct itself and the underlying
 * data buffer it points to.
 *
 * # Memory Management
 *
 * The memory for this struct and its data buffer is allocated by the Rust
 * library. Therefore, it **MUST** be deallocated by the Rust library.
 *
 * The C caller is responsible for passing the pointer they receive back to
 * the `archive_data_free` function to release the memory. Failure to do so
 * will result in a memory leak.
 *
 * **Warning:** Do NOT attempt to free the `data` pointer manually using
 * `free()` in C. The memory is managed by Rust's allocator, and attempting to
 * free it with a different allocator will lead to heap corruption and
 * undefined behavior.
 */
typedef struct FFIArchiveData {
  uint8_t *data;
  uintptr_t data_len;
  uintptr_t data_cap;
} FFIArchiveData;

/**
 * FFI-safe equivalent of `ChunkLocation`, representing a slice of the
 * compressed data in an archive.
 *
 * This struct is used within the chunk index to specify the exact location
 * and size of a compressed data chunk. It provides the necessary information
 * to read a chunk's data from the archive's data section for decompression.
 *
 * # Fields
 *
 * * `offset`: The starting byte position of the chunk, relative to the
 *   beginning of the archive's main data section.
 * * `length`: The total size of the compressed chunk in bytes.
 */
typedef struct FFIChunkLocation {
  uint64_t offset;
  uint32_t length;
} FFIChunkLocation;

/**
 * Represents a single entry in the archive's chunk index.
 *
 * This struct maps a unique chunk hash to its physical location within the
 * compressed data section of the archive. An array of these entries makes up
 * the complete chunk index, which is essential for locating and decompressing
 * chunk data during file extraction.
 *
 * This is the FFI-safe equivalent of a `(H, ChunkLocation)` tuple.
 *
 * # Type Parameters
 *
 * * `H`: The generic hash type (e.g., `u64`, `u128`) used to identify the
 *   chunk.
 *
 * # Fields
 *
 * * `hash`: The unique deduplication hash of the data chunk.
 * * `data`: An `FFIChunkLocation` struct specifying the offset and length of
 *   the compressed chunk data in the archive.
 */
typedef struct FFIChunkIndexEntry_u64 {
  uint64_t hash;
  struct FFIChunkLocation data;
} FFIChunkIndexEntry_u64;

/**
 * Holds the result of parsing a serialized chunk index from an archive.
 *
 * This struct is returned by the `parse_file_chunk_index_*` functions.
 * It provides a C-compatible representation of the entire chunk index, which
 * maps every unique chunk hash to its location within the archive's data
 * section.
 *
 * # Type Parameters
 *
 * * `H`: The generic hash type (e.g., `u64`, `u128`) used in the chunk
 *   index.
 *
 * # Fields
 *
 * * `entries`: A pointer to the beginning of a contiguous array of
 *   [`FFIChunkIndexEntry`] structs.
 * * `entries_len`: The total number of entries in the `entries` array.
 *
 * # Safety
 *
 * The C caller takes full ownership of the memory for this struct and the
 * `entries` array it points to. To prevent a memory leak, the top-level
 * pointer to this struct **must** be passed to the corresponding
 * `free_parsed_chunk_index_*` function once it is no longer needed.
 */
typedef struct FFIParsedChunkIndexArray_u64 {
  struct FFIChunkIndexEntry_u64 *entries;
  uintptr_t entries_len;
  uintptr_t entries_cap;
} FFIParsedChunkIndexArray_u64;

/**
 * An `FFIParsedChunkIndexArray` specialized for `u64` hashes.
 *
 * This type is returned by [`parse_file_chunk_index_u64`] and is the
 * expected input for [`free_parsed_chunk_index_u64`]. It represents a
 * complete chunk index where each chunk is identified by a 64-bit hash.
 */
typedef struct FFIParsedChunkIndexArray_u64 FFIParsedChunkIndexArrayU64;

/**
 * Represents a single entry in the archive's chunk index.
 *
 * This struct maps a unique chunk hash to its physical location within the
 * compressed data section of the archive. An array of these entries makes up
 * the complete chunk index, which is essential for locating and decompressing
 * chunk data during file extraction.
 *
 * This is the FFI-safe equivalent of a `(H, ChunkLocation)` tuple.
 *
 * # Type Parameters
 *
 * * `H`: The generic hash type (e.g., `u64`, `u128`) used to identify the
 *   chunk.
 *
 * # Fields
 *
 * * `hash`: The unique deduplication hash of the data chunk.
 * * `data`: An `FFIChunkLocation` struct specifying the offset and length of
 *   the compressed chunk data in the archive.
 */
typedef struct FFIChunkIndexEntry_U128Bytes {
  struct U128Bytes hash;
  struct FFIChunkLocation data;
} FFIChunkIndexEntry_U128Bytes;

/**
 * Holds the result of parsing a serialized chunk index from an archive.
 *
 * This struct is returned by the `parse_file_chunk_index_*` functions.
 * It provides a C-compatible representation of the entire chunk index, which
 * maps every unique chunk hash to its location within the archive's data
 * section.
 *
 * # Type Parameters
 *
 * * `H`: The generic hash type (e.g., `u64`, `u128`) used in the chunk
 *   index.
 *
 * # Fields
 *
 * * `entries`: A pointer to the beginning of a contiguous array of
 *   [`FFIChunkIndexEntry`] structs.
 * * `entries_len`: The total number of entries in the `entries` array.
 *
 * # Safety
 *
 * The C caller takes full ownership of the memory for this struct and the
 * `entries` array it points to. To prevent a memory leak, the top-level
 * pointer to this struct **must** be passed to the corresponding
 * `free_parsed_chunk_index_*` function once it is no longer needed.
 */
typedef struct FFIParsedChunkIndexArray_U128Bytes {
  struct FFIChunkIndexEntry_U128Bytes *entries;
  uintptr_t entries_len;
  uintptr_t entries_cap;
} FFIParsedChunkIndexArray_U128Bytes;

/**
 * An `FFIParsedChunkIndexArray` specialized for `u128` hashes.
 *
 * This type is returned by [`parse_file_chunk_index_u128`] and is the
 * expected input for [`free_parsed_chunk_index_u128`]. It represents a
 * complete chunk index where each chunk is identified by a 128-bit hash,
 * represented on the FFI boundary as a [u8; 16] byte array in a U128Bytes
 * struct.
 */
typedef struct FFIParsedChunkIndexArray_U128Bytes FFIParsedChunkIndexArrayU128;

/**
 * Defines the header structure for an archive file.
 *
 * This struct represents the first block of data in an archive. It acts
 * as a primary index, providing metadata required to parse the rest of
 * the file. It includes a magic number, version, and the offsets and
 * lengths of all major data sections, such as the file manifest, chunk
 * index, and compressed data.
 *
 * # Fields
 *
 * * `magic_num`: A 4-byte array to identify the file as a valid archive.
 * * `file_version`: The version number of the archive format.
 * * `file_count`: The total number of files stored in the archive.
 * * `algorithm`: Numerical value representing the compression used on the
 *   compressed data.
 * * `hash_type`: Numerical value representing the hash type used when
 *   the data was hashed. 1 = xxhash3_64, 2 = xxhash3_128
 * * `pad`: Empty data padding to keep data aligned. Must be all zeros.
 * * `man_offset`: The byte offset where the file manifest begins.
 * * `man_length`: The total length of the file manifest in bytes.
 * * `dict_offset`: The starting offset of the compression dictionary.
 * * `dict_length`: The total length of the dictionary in bytes.
 * * `chunk_index_offset`: The byte offset for the chunk index.
 * * `chunk_index_length`: The total length of the chunk index.
 * * `data_offset`: The starting offset of the compressed file data.
 */
typedef struct FileHeader {
  uint8_t magic_num[8];
  uint32_t file_version;
  uint32_t file_count;
  uint16_t algorithm;
  uint8_t hash_type;
  uint8_t pad[5];
  uint64_t man_offset;
  uint64_t man_length;
  uint64_t dict_offset;
  uint64_t dict_length;
  uint64_t chunk_index_offset;
  uint64_t chunk_index_length;
  uint64_t data_offset;
} FileHeader;

/**
 * Holds the result of parsing a serialized file manifest from an archive.
 *
 * This struct is returned by the `parse_file_metadata_*` functions and
 * provides a C-compatible representation of the entire file manifest. It
 * contains an array of [`FFIFileManifestParent`] structs, each describing a
 * single file within the archive.
 *
 * # Type Parameters
 *
 * * `H`: The generic hash type (e.g., `u64`, `u128`) used in the chunk
 *   metadata within each manifest.
 *
 * # Fields
 *
 * * `manifests`: A pointer to the beginning of a contiguous array of
 *   [`FFIFileManifestParent`] structs.
 * * `manifests_len`: The total number of manifest entries in the `manifests`
 *   array.
 *
 * # Safety
 *
 * The C caller takes full ownership of the memory for this struct and all the
 * nested data it points to (the `manifests` array, and the internal pointers
 * for filenames and chunk metadata within each manifest). To prevent
 * significant memory leaks, the top-level pointer to this struct **must** be
 * passed to the corresponding `free_parsed_manifest_*` function once it
 * is no longer needed.
 */
typedef struct FFIParsedManifestArray_u64 {
  struct FFIFileManifestParent_u64 *manifests;
  uintptr_t manifests_len;
  uintptr_t manifests_cap;
} FFIParsedManifestArray_u64;

/**
 * An `FFIParsedManifestArray` specialized for `u64` hashes.
 *
 * This type is returned by [`parse_file_metadata_u64`] and is the
 * expected input for [`free_parsed_manifest_u64`]. It represents a
 * complete file manifest where each chunk is identified by a 64-bit hash.
 */
typedef struct FFIParsedManifestArray_u64 FFIParsedManifestArrayU64;

/**
 * Holds the result of parsing a serialized file manifest from an archive.
 *
 * This struct is returned by the `parse_file_metadata_*` functions and
 * provides a C-compatible representation of the entire file manifest. It
 * contains an array of [`FFIFileManifestParent`] structs, each describing a
 * single file within the archive.
 *
 * # Type Parameters
 *
 * * `H`: The generic hash type (e.g., `u64`, `u128`) used in the chunk
 *   metadata within each manifest.
 *
 * # Fields
 *
 * * `manifests`: A pointer to the beginning of a contiguous array of
 *   [`FFIFileManifestParent`] structs.
 * * `manifests_len`: The total number of manifest entries in the `manifests`
 *   array.
 *
 * # Safety
 *
 * The C caller takes full ownership of the memory for this struct and all the
 * nested data it points to (the `manifests` array, and the internal pointers
 * for filenames and chunk metadata within each manifest). To prevent
 * significant memory leaks, the top-level pointer to this struct **must** be
 * passed to the corresponding `free_parsed_manifest_*` function once it
 * is no longer needed.
 */
typedef struct FFIParsedManifestArray_U128Bytes {
  struct FFIFileManifestParent_U128Bytes *manifests;
  uintptr_t manifests_len;
  uintptr_t manifests_cap;
} FFIParsedManifestArray_U128Bytes;

/**
 * An `FFIParsedManifestArray` specialized for `u128` hashes.
 *
 * This type is returned by [`parse_file_metadata_u128`] and is the
 * expected input for [`free_parsed_manifest_u128`]. It represents a
 * complete file manifest where each chunk is identified by a 128-bit hash.
 */
typedef struct FFIParsedManifestArray_U128Bytes FFIParsedManifestArrayU128;

/**
 * FFI-safe equivalent of a `fastcdc::Chunk`, representing a content-defined
 * segment of a file.
 *
 * This struct is used to pass chunking information from Rust to a C caller.
 * It describes a single chunk identified by the FastCDC algorithm, including
 * its hash, its starting offset in the original file, and its length.
 *
 * # Fields
 *
 * * `hash`: The gear hash value calculated by the chunking algorithm as of
 *   the end of the chunk. Note that this is **not** the deduplication hash
 *   of the chunk's content.
 * * `offset`: The starting byte position of this chunk within the original,
 *   uncompressed source file.
 * * `length`: The total length of the chunk in bytes.
 */
typedef struct FFIChunk {
  /**
   * Gear hash value as of the end of the chunk.
   */
  uint64_t hash;
  /**
   * Starting byte position in the source.
   */
  uintptr_t offset;
  /**
   * Length of the chunk in bytes.
   */
  uintptr_t length;
} FFIChunk;

/**
 * Arguments used by the `create_file_manifest_and_chunks_u64`
 * and `create_file_manifest_and_chunks_u128`FFI functions.
 *
 * This struct is a plain‑old‑data (POD) container that can be safely passed
 * across the FFI boundary. It bundles the raw pointers and lengths required
 * to construct a file manifest together with the list of chunk descriptors
 * supplied by the caller.
 *
 * # Fields
 *
 * * `file_name_ptr`: Pointer to a null‑terminated C string (`*const c_char`)
 *   containing the file name. The caller must guarantee that the string is
 *   valid for the lifetime of the call.
 * * `file_data_array_ptr`: Pointer to the start of the file’s raw byte data
 *   (`*const u8`). The slice represented by this pointer must be at least
 *   `file_data_len` bytes long.
 * * `file_data_len`: Length, in bytes, of the data slice pointed to by
 *   `file_data_array_ptr`. Must be exactly the size of the file’s contents.
 * * `chunks_array_ptr`: Pointer to an array of `FFIChunk` structs that
 *   describe the individual chunks (hash, offset, length) belonging to the
 *   file.
 * * `chunks_len`: Number of `FFIChunk` entries in the `chunks_array_ptr`
 *   array.
 *
 * The struct does not own any memory; ownership is transferred to the
 * internal Rust implementation when the arguments are dereferenced. After
 * the call, the caller is responsible for freeing the returned
 * `FFIFileManifestChunksU*` object via the matching
 * `free_file_manifest_and_chunks_*` function.
 */
typedef struct CreateFileManifestAndChunksArgs {
  const char *file_name_ptr;
  const uint8_t *file_data_array_ptr;
  uintptr_t file_data_len;
  const struct FFIChunk *chunks_array_ptr;
  uintptr_t chunks_len;
} CreateFileManifestAndChunksArgs;

/**
 * Represents a chunk's unique hash and its associated raw, uncompressed data.
 *
 * This struct is used to pass the fundamental components of a file's content
 * from Rust to a C caller. An array of these structs is a key output of the
 * `create_file_manifest_and_chunks_*` functions, providing the C
 * application with a complete set of all data chunks from a processed file,
 * each paired with its deduplication hash.
 *
 * # Type Parameters
 *
 * * `H`: The generic hash type (e.g., `u64`, `u128`) used to uniquely
 *   identify the chunk's content.
 *
 * # Fields
 *
 * * `hash`: The unique deduplication hash (e.g., xxhash3) of the chunk's
 *   content.
 * * `chunk_data`: A raw pointer to the beginning of a byte array containing
 *   the chunk's uncompressed data.
 * * `chunk_data_len`: The number of bytes in the `chunk_data` array.
 *
 * # Safety
 *
 * When this struct is created by Rust and passed to C, the C caller takes
 * full ownership of the memory pointed to by `chunk_data`. To prevent a
 * memory leak, this memory **must** be deallocated by calling the
 * appropriate free function (e.g., `free_file_manifest_and_chunks_*`),
 * which handles the cleanup of all nested data.
 */
typedef struct FFIHashedChunkData_u64 {
  uint64_t hash;
  uint8_t *chunk_data;
  uintptr_t chunk_data_len;
  uintptr_t chunk_data_cap;
} FFIHashedChunkData_u64;

/**
 * A composite FFI structure that bundles a file's manifest with its
 * associated hashed chunk data.
 *
 * This struct is returned by the `create_file_manifest_and_chunks_*`
 * functions. It contains all the necessary information generated from
 * processing a single file: the metadata needed for reconstruction (the
 * manifest) and the list of unique, hashed chunks that compose the file's
 * content.
 *
 * # Type Parameters
 *
 * * `H`: The generic hash type (e.g., `u64`, `u128`) used to identify the
 *   chunks.
 *
 * # Fields
 *
 * * `fmp`: An [`FFIFileManifestParent`] struct containing the file's
 *   metadata, such as its name and an ordered list of its chunk metadata.
 * * `hashed_chunks`: A pointer to an array of [`FFIHashedChunkData`] structs.
 *   Each struct in this array contains a chunk's unique hash and a pointer
 *   to its raw, uncompressed data.
 * * `hashed_chunks_len`: The number of elements in the `hashed_chunks` array.
 *
 * # Safety
 *
 * The C caller takes full ownership of the memory for this struct and all
 * the nested data it points to. To prevent significant memory leaks, the
 * top-level pointer to this struct **must** be passed to the corresponding
 * `free_file_manifest_and_chunks_*` function. This free function will
 * correctly deallocate the `fmp`'s internal data, the `hashed_chunks` array,
 * and the raw data buffer for each individual chunk.
 */
typedef struct FFIFileManifestChunks_u64 {
  struct FFIFileManifestParent_u64 fmp;
  struct FFIHashedChunkData_u64 *hashed_chunks;
  uintptr_t hashed_chunks_len;
  uintptr_t hashed_chunks_cap;
} FFIFileManifestChunks_u64;

/**
 * An `FFIFileManifestChunks` struct specialized for `u64` hashes.
 *
 * This type is returned by [`create_file_manifest_and_chunks_u64`] and
 * is the expected input for [`free_file_manifest_and_chunks_u64`]. It
 * bundles the file manifest and its chunk data when the hash algorithm
 * produces a 64-bit integer.
 */
typedef struct FFIFileManifestChunks_u64 FFIFileManifestChunksU64;

/**
 * Represents a chunk's unique hash and its associated raw, uncompressed data.
 *
 * This struct is used to pass the fundamental components of a file's content
 * from Rust to a C caller. An array of these structs is a key output of the
 * `create_file_manifest_and_chunks_*` functions, providing the C
 * application with a complete set of all data chunks from a processed file,
 * each paired with its deduplication hash.
 *
 * # Type Parameters
 *
 * * `H`: The generic hash type (e.g., `u64`, `u128`) used to uniquely
 *   identify the chunk's content.
 *
 * # Fields
 *
 * * `hash`: The unique deduplication hash (e.g., xxhash3) of the chunk's
 *   content.
 * * `chunk_data`: A raw pointer to the beginning of a byte array containing
 *   the chunk's uncompressed data.
 * * `chunk_data_len`: The number of bytes in the `chunk_data` array.
 *
 * # Safety
 *
 * When this struct is created by Rust and passed to C, the C caller takes
 * full ownership of the memory pointed to by `chunk_data`. To prevent a
 * memory leak, this memory **must** be deallocated by calling the
 * appropriate free function (e.g., `free_file_manifest_and_chunks_*`),
 * which handles the cleanup of all nested data.
 */
typedef struct FFIHashedChunkData_U128Bytes {
  struct U128Bytes hash;
  uint8_t *chunk_data;
  uintptr_t chunk_data_len;
  uintptr_t chunk_data_cap;
} FFIHashedChunkData_U128Bytes;

/**
 * A composite FFI structure that bundles a file's manifest with its
 * associated hashed chunk data.
 *
 * This struct is returned by the `create_file_manifest_and_chunks_*`
 * functions. It contains all the necessary information generated from
 * processing a single file: the metadata needed for reconstruction (the
 * manifest) and the list of unique, hashed chunks that compose the file's
 * content.
 *
 * # Type Parameters
 *
 * * `H`: The generic hash type (e.g., `u64`, `u128`) used to identify the
 *   chunks.
 *
 * # Fields
 *
 * * `fmp`: An [`FFIFileManifestParent`] struct containing the file's
 *   metadata, such as its name and an ordered list of its chunk metadata.
 * * `hashed_chunks`: A pointer to an array of [`FFIHashedChunkData`] structs.
 *   Each struct in this array contains a chunk's unique hash and a pointer
 *   to its raw, uncompressed data.
 * * `hashed_chunks_len`: The number of elements in the `hashed_chunks` array.
 *
 * # Safety
 *
 * The C caller takes full ownership of the memory for this struct and all
 * the nested data it points to. To prevent significant memory leaks, the
 * top-level pointer to this struct **must** be passed to the corresponding
 * `free_file_manifest_and_chunks_*` function. This free function will
 * correctly deallocate the `fmp`'s internal data, the `hashed_chunks` array,
 * and the raw data buffer for each individual chunk.
 */
typedef struct FFIFileManifestChunks_U128Bytes {
  struct FFIFileManifestParent_U128Bytes fmp;
  struct FFIHashedChunkData_U128Bytes *hashed_chunks;
  uintptr_t hashed_chunks_len;
  uintptr_t hashed_chunks_cap;
} FFIFileManifestChunks_U128Bytes;

/**
 * An `FFIFileManifestChunks` struct specialized for `u128` hashes.
 *
 * This type is returned by [`create_file_manifest_and_chunks_u128`] and
 * is the expected input for [`free_file_manifest_and_chunks_u128`]. It
 * bundles the file manifest and its chunk data when the hash algorithm
 * produces a 128-bit integer, represented on the FFI boundary as a [u8; 16]
 * byte array in a U128Bytes struct.
 */
typedef struct FFIFileManifestChunks_U128Bytes FFIFileManifestChunksU128;

/**
 * FFI-safe equivalent of `FileData`, used to pass the contents of a single
 * file from a C caller into Rust.
 *
 * This struct provides a language-agnostic way to represent a file's name
 * and its complete binary data, allowing Rust functions to process files
 * managed by a C application without needing to perform file I/O directly.
 *
 * # Fields
 *
 * * `filename`: A pointer to a null-terminated C string representing the
 *   name of the file.
 * * `file_data`: A raw pointer to the beginning of a byte array containing
 *   the file's entire contents.
 * * `file_data_len`: The number of bytes in the `file_data` array.
 *
 * # Safety
 *
 * The C caller retains ownership of the memory pointed to by `filename` and
 * `file_data`. Rust will only read from these pointers for the duration of
 * the FFI call and will not attempt to deallocate them. The C caller must
 * ensure these pointers are valid, non-null, and point to memory that is
 * readable for their specified lengths for the lifetime of the call.
 */
typedef struct FFIFileData {
  const char *filename;
  const uint8_t *file_data;
  uintptr_t file_data_len;
} FFIFileData;

/**
 * Holds all the output data from processing a single file in memory via the
 * FFI.
 *
 * This struct is returned by the [`process_file_in_memory_ffi`] function. It
 * bundles all critical information generated after a file has been read and
 * analyzed, including its name, its content-defined chunks, its raw data,
 * and a verification hash for data integrity.
 *
 * # Fields
 *
 * * `filename`: A pointer to a null-terminated C string containing the name
 *   of the processed file.
 * * `filename_len`: The length of the `filename` string in bytes, excluding
 *   the null terminator.
 * * `veri_hash`: A pointer to a 64-byte array containing the SHA-512 hash of
 *   the original file's contents.
 * * `chunks`: A pointer to the beginning of a contiguous array of
 *   [`FFIChunk`] structs, representing the file's content-defined chunks.
 * * `chunks_len`: The total number of `FFIChunk` structs in the `chunks`
 *   array.
 * * `file_data`: A raw pointer to a byte array holding the complete, original
 *   contents of the file.
 * * `file_data_len`: The number of bytes in the `file_data` array.
 *
 * # Safety
 *
 * The C caller takes full ownership of the memory for this struct and all the
 * nested data it points to (`filename`, `veri_hash`, `chunks`, and
 * `file_data`). To prevent significant memory leaks, the top-level pointer to
 * this struct **must** be passed to the [`free_processed_file_data_ffi`]
 * function once it is no longer needed.
 */
typedef struct FFIProcessedFileData {
  char *filename;
  uintptr_t filename_len;
  uint8_t (*veri_hash)[64];
  struct FFIChunk *chunks;
  uintptr_t chunks_len;
  uintptr_t chunks_cap;
  uint8_t *file_data;
  uintptr_t file_data_len;
  uintptr_t file_data_cap;
} FFIProcessedFileData;

/**
 * Arguments required to verify a single file using the
 * verify_single_file_u128 function.
 *
 * This struct is passed by pointer to the `verify_single_file_u128` FFI entry
 * point. All pointers must be valid for the duration of the call; the parent
 * application will not take ownership of any of the data.
 *
 * # Fields
 *
 * * `file_manifest_parent`: Pointer to an `FFIFileManifestParentU128` that
 *   describes the file manifest (filename and related chunk metadata). Must
 *   be non‑null and point to a properly‑initialized struct that lives at
 *   least until the verification completes.
 * * `veri_hash_array_ptr`: Pointer to a byte buffer that contains the
 *   expected verification hashes for the file. The buffer must be a length of
 *   64 (64 x 8 bytes).
 * * `user_data`: Opaque pointer passed unchanged to the callback functions.
 *   It can be used by the caller to store context (e.g., a Rust
 *   `Arc<Mutex<…>>` or a raw pointer to a C struct). The parent application
 *   never dereferences this pointer; it is only handed back to the callbacks.
 * * `get_chunks_cb`: Callback invoked by the verifier when it needs to
 *   retrieve the raw chunk data for a set of hash values.
 *   It must return an `FFIChunkDataArray` describing a contiguous buffer that
 *   contains the requested chunk data. The returned buffer is owned by the
 *   caller and must remain valid until the next callback invocation.
 *   The callback receives:
 *   - `user_data`: the same pointer passed in this struct,
 *   - `hashes`: pointer to an array of `u128` hash identifiers,
 *   - `hashes_len`: length of the `hashes` array.
 *
 * * `progress_cb`: Optional progress callback. It is called periodically with
 *   the number of bytes processed so far.
 *
 * # Safety
 *
 * This struct is used across the FFI boundary, so all pointers must be
 * correctly aligned and point to memory that lives long enough. Supplying a
 * dangling or incorrectly sized pointer results in undefined behaviour. The
 * callbacks themselves must also obey the FFI safety contract: they may not
 * unwind across the FFI boundary and must not dereference any pointers other
 * than those provided to them.
 */
typedef struct VerifySingleFileArgsU128 {
  const FFIFileManifestParentU128 *file_manifest_parent;
  const uint8_t *veri_hash_array_ptr;
  void *user_data;
  struct FFIChunkDataArray (*get_chunks_cb)(void *user_data,
                                            const uint8_t *hashes,
                                            uintptr_t hashes_len);
  void (*progress_cb)(void *user_data, uint64_t bytes_processed);
} VerifySingleFileArgsU128;

/**
 * A composite FFI struct that bundles the arguments for the
 * `test_compression` logic.
 *
 * This struct is used as a helper to bundle the many parameters that are
 * passed from the public `test_compression_*` FFI functions to the internal
 * implementation. It is constructed in Rust and never crosses the FFI
 * boundary.
 *
 * # Fields
 *
 * * `total_data_size`: The total combined size in bytes of all unique
 *   chunks.
 * * `sorted_hashes_array_ptr`: Pointer to a contiguous array of sorted hash
 *   values.
 * * `sorted_hashes_len`: Number of hash entries in the
 *   `sorted_hashes_array_ptr` array.
 * * `worker_count`: The number of threads to use for parallel compression.
 * * `dictionary_size`: Desired size (in bytes) of the temporary dictionary.
 * * `compression_level`: The Zstandard compression level to be used by the
 *   worker threads. When testing a maximum value of 7 is used.
 * * `user_data`: Opaque user‑supplied context that will be passed back to
 *   the `get_chunks_cb` callback.
 * * `get_chunks_cb`: A C-style callback function pointer to retrieve raw
 *   chunk data.
 *   The callback receives:
 *   - `user_data`: the opaque pointer supplied above,
 *   - `hashes`: pointer to the requested hash slice,
 *   - `hashes_len`: length of that slice,
 *   - `out_chunks`: pointer to an `FFIChunkDataArray` that the callback must
 *     fill
 */
typedef struct TestCompressionArgs_u64 {
  uint64_t total_data_size;
  const uint64_t *sorted_hashes_array_ptr;
  uintptr_t sorted_hashes_len;
  uintptr_t worker_count;
  uintptr_t dictionary_size;
  int32_t compression_level;
  void *user_data;
  enum FFICallbackStatus (*get_chunks_cb)(void *user_data,
                                          const uint64_t *hashes,
                                          uintptr_t hashes_len,
                                          struct FFIChunkDataArray *out_chunks);
} TestCompressionArgs_u64;

/**
 * Bundles all parameters for calling the `test_compression_u64` function.
 *
 * This struct is passed by pointer to `test_compression_u64` to provide all
 * the necessary data for running a compression test, including the set of unique
 * chunk hashes and a callback for retrieving chunk data.
 *
 * # Fields
 *
 * * `total_data_size`: The total combined size in bytes of all unique chunks.
 * * `sorted_hashes_array_ptr`: A pointer to a contiguous array of all unique
 *   `u64` chunk hashes, sorted in a deterministic order.
 * * `sorted_hashes_len`: The number of hashes in the
 *   `sorted_hashes_array_ptr` array.
 * * `worker_count`: The number of threads to use for parallel compression.
 * * `dictionary_size`: Desired size (in bytes) of the temporary dictionary to
 *   be built and tested.
 * * `compression_level`: The Zstandard compression level to test.
 * * `user_data`: An opaque `void` pointer that is passed back to the
 *   `get_chunks_cb` callback, allowing the C side to maintain state.
 * * `get_chunks_cb`: A C function pointer that the test runner calls to
 *   request the raw data for a set of hashes.
 *
 * # Safety
 *
 * The C caller is responsible for ensuring that all pointers within this
 * struct are non-null and point to valid memory for the duration of the
 * `test_compression_u64` call.
 */
typedef struct TestCompressionArgs_u64 TestCompressionArgsU64;

/**
 * A composite FFI struct that bundles the arguments for the
 * `test_compression` logic.
 *
 * This struct is used as a helper to bundle the many parameters that are
 * passed from the public `test_compression_*` FFI functions to the internal
 * implementation. It is constructed in Rust and never crosses the FFI
 * boundary.
 *
 * # Fields
 *
 * * `total_data_size`: The total combined size in bytes of all unique
 *   chunks.
 * * `sorted_hashes_array_ptr`: Pointer to a contiguous array of sorted hash
 *   values.
 * * `sorted_hashes_len`: Number of hash entries in the
 *   `sorted_hashes_array_ptr` array.
 * * `worker_count`: The number of threads to use for parallel compression.
 * * `dictionary_size`: Desired size (in bytes) of the temporary dictionary.
 * * `compression_level`: The Zstandard compression level to be used by the
 *   worker threads. When testing a maximum value of 7 is used.
 * * `user_data`: Opaque user‑supplied context that will be passed back to
 *   the `get_chunks_cb` callback.
 * * `get_chunks_cb`: A C-style callback function pointer to retrieve raw
 *   chunk data.
 *   The callback receives:
 *   - `user_data`: the opaque pointer supplied above,
 *   - `hashes`: pointer to the requested hash slice,
 *   - `hashes_len`: length of that slice,
 *   - `out_chunks`: pointer to an `FFIChunkDataArray` that the callback must
 *     fill
 */
typedef struct TestCompressionArgs_u8 {
  uint64_t total_data_size;
  const uint8_t *sorted_hashes_array_ptr;
  uintptr_t sorted_hashes_len;
  uintptr_t worker_count;
  uintptr_t dictionary_size;
  int32_t compression_level;
  void *user_data;
  enum FFICallbackStatus (*get_chunks_cb)(void *user_data,
                                          const uint8_t *hashes,
                                          uintptr_t hashes_len,
                                          struct FFIChunkDataArray *out_chunks);
} TestCompressionArgs_u8;

/**
 * Bundles all parameters for calling the `test_compression_u128` function.
 *
 * This struct is passed by pointer to `test_compression_u128` to provide all
 * the necessary data for running a compression test, including the set of
 * unique chunk hashes and a callback for retrieving chunk data.
 *
 * # Fields
 *
 * * `total_data_size`: The total combined size in bytes of all unique chunks.
 * * `sorted_hashes_array_ptr`: A pointer to a contiguous array of all unique
 *   `u128` chunk hashes, sorted in a deterministic order, represented on the
 *   FFI boundary as a [u8; 16] byte array.
 * * `sorted_hashes_len`: The number of hashes in the
 *   `sorted_hashes_array_ptr` array.
 * * `worker_count`: The number of threads to use for parallel compression.
 * * `dictionary_size`: Desired size (in bytes) of the temporary dictionary to
 *   be built and tested.
 * * `compression_level`: The Zstandard compression level to test.
 * * `user_data`: An opaque `void` pointer that is passed back to the
 *   `get_chunks_cb` callback, allowing the C side to maintain state.
 * * `get_chunks_cb`: A C function pointer that the test runner calls to
 *   request the raw data for a set of hashes.
 *
 * # Safety
 *
 * The C caller is responsible for ensuring that all pointers within this
 * struct are non-null and point to valid memory for the duration of the
 * `test_compression_u128` call.
 */
typedef struct TestCompressionArgs_u8 TestCompressionArgsU128;

/**
 * Contains the necessary information to read a specific byte range from a
 * single chunk to fulfill a file seek request.
 *
 * When a caller requests a specific byte range from a file (a seek
 * operation), this struct identifies one of the chunks that contains part of
 * the required data. An array of these structs tells the caller exactly which
 * chunks to decompress and which parts of the resulting data to copy to
 * reconstruct the requested byte range.
 *
 * # Type Parameters
 *
 * * `H`: The generic hash type (e.g., `u64`, `u128`) used to identify the
 *   chunk.
 *
 * # Fields
 *
 * * `hash`: The unique hash of the required data chunk.
 * * `read_start`: The starting byte offset within the *decompressed* chunk
 *   data from where to begin reading.
 * * `read_end`: The exclusive ending byte offset within the *decompressed*
 *   chunk data where reading should stop.
 */
typedef struct FFISeekChunkInfo_u64 {
  uint64_t hash;
  uint64_t read_start;
  uint64_t read_end;
} FFISeekChunkInfo_u64;

/**
 * Holds the result of a file seek calculation, specifying which chunks are
 * needed to reconstruct a requested byte range.
 *
 * This struct is returned by the `get_seek_chunks_ffi_*` functions. It
 * contains a complete list of all the chunks that must be read and
 * decompressed to satisfy a seek request, along with the specific byte
 * ranges to copy from each one.
 *
 * # Type Parameters
 *
 * * `H`: The generic hash type (e.g., `u64`, `u128`) used to identify the
 *   chunks.
 *
 * # Fields
 *
 * * `chunks`: A pointer to the beginning of a contiguous array of
 *   [`FFISeekChunkInfo`] structs. Each struct in this array identifies a
 *   required chunk and the byte range to read from it after decompression.
 * * `chunks_len`: The total number of `FFISeekChunkInfo` structs in the
 *   `chunks` array.
 *
 * # Safety
 *
 * The C caller takes full ownership of the memory for this struct and the
 * `chunks` array it points to. To prevent a memory leak, the top-level
 * pointer to this struct **must** be passed to the corresponding
 * `free_seek_chunks_ffi_*` function once it is no longer needed.
 */
typedef struct FFISeekInfoArray_u64 {
  struct FFISeekChunkInfo_u64 *chunks;
  uintptr_t chunks_len;
  uintptr_t chunks_cap;
} FFISeekInfoArray_u64;

/**
 * An `FFISeekInfoArray` specialized for `u64` hashes.
 *
 * This type is returned by [`get_seek_chunks_ffi_u64`] and is the
 * expected input for [`free_seek_chunks_ffi_u64`]. It provides a complete
 * list of all chunks and byte ranges required to fulfill a seek request where
 * chunks are identified by 64-bit hashes.
 */
typedef struct FFISeekInfoArray_u64 FFISeekInfoArrayU64;

/**
 * Contains the necessary information to read a specific byte range from a
 * single chunk to fulfill a file seek request.
 *
 * When a caller requests a specific byte range from a file (a seek
 * operation), this struct identifies one of the chunks that contains part of
 * the required data. An array of these structs tells the caller exactly which
 * chunks to decompress and which parts of the resulting data to copy to
 * reconstruct the requested byte range.
 *
 * # Type Parameters
 *
 * * `H`: The generic hash type (e.g., `u64`, `u128`) used to identify the
 *   chunk.
 *
 * # Fields
 *
 * * `hash`: The unique hash of the required data chunk.
 * * `read_start`: The starting byte offset within the *decompressed* chunk
 *   data from where to begin reading.
 * * `read_end`: The exclusive ending byte offset within the *decompressed*
 *   chunk data where reading should stop.
 */
typedef struct FFISeekChunkInfo_U128Bytes {
  struct U128Bytes hash;
  uint64_t read_start;
  uint64_t read_end;
} FFISeekChunkInfo_U128Bytes;

/**
 * Holds the result of a file seek calculation, specifying which chunks are
 * needed to reconstruct a requested byte range.
 *
 * This struct is returned by the `get_seek_chunks_ffi_*` functions. It
 * contains a complete list of all the chunks that must be read and
 * decompressed to satisfy a seek request, along with the specific byte
 * ranges to copy from each one.
 *
 * # Type Parameters
 *
 * * `H`: The generic hash type (e.g., `u64`, `u128`) used to identify the
 *   chunks.
 *
 * # Fields
 *
 * * `chunks`: A pointer to the beginning of a contiguous array of
 *   [`FFISeekChunkInfo`] structs. Each struct in this array identifies a
 *   required chunk and the byte range to read from it after decompression.
 * * `chunks_len`: The total number of `FFISeekChunkInfo` structs in the
 *   `chunks` array.
 *
 * # Safety
 *
 * The C caller takes full ownership of the memory for this struct and the
 * `chunks` array it points to. To prevent a memory leak, the top-level
 * pointer to this struct **must** be passed to the corresponding
 * `free_seek_chunks_ffi_*` function once it is no longer needed.
 */
typedef struct FFISeekInfoArray_U128Bytes {
  struct FFISeekChunkInfo_U128Bytes *chunks;
  uintptr_t chunks_len;
  uintptr_t chunks_cap;
} FFISeekInfoArray_U128Bytes;

/**
 * An `FFISeekInfoArray` specialized for `u128` hashes.
 *
 * This type is returned by [`get_seek_chunks_ffi_u128`] and is the
 * expected input for [`free_seek_chunks_ffi_u128`]. It provides a complete
 * list of all chunks and byte ranges required to fulfill a seek request where
 * chunks are identified by 128-bit hashes, represented on the FFI boundary
 * as a [u8; 16] byte array in a U128Bytes struct.
 */
typedef struct FFISeekInfoArray_U128Bytes FFISeekInfoArrayU128;

/**
 * FFI-safe struct for passing an array of keys from C to Rust.
 *
 * * `ptr`: A pointer to the first element of a contiguous array of keys.
 * * `len`: Number of elements in the array.
 * * `cap`: Capacity of the allocated array.
 *
 * # Memory Management
 *
 * The C caller allocates the array and the key values.  When this struct is
 * passed to Rust, Rust takes ownership of the buffer and will deallocate
 * it when the `FFIKeyArray` is dropped.  The caller must **not** free the
 * memory after the FFI call returns.
 *
 * # Type Parameters
 *
 * * `H` – hash type (`u64`, `u128`, …).  The key type is generic so the
 *   struct can be specialized for any hash size.
 *
 * # Usage
 *
 * In the serialization FFI, `get_keys_cb` fills a `FFIKeyArray` and the
 * Rust side consumes it with `Vec::from_raw_parts`, yielding a `Vec<H>`
 * that is automatically dropped.  If `len` is zero, `ptr` may be null.
 */
typedef struct FFIKeyArray_u64 {
  uint64_t *ptr;
  uintptr_t len;
  uintptr_t cap;
} FFIKeyArray_u64;

/**
 * An `FFIKeyArray` specialized for `u64` hashes.
 *
 * This type is used in FFI functions that deal with hash keys where the
 * chunk hash algorithm produces a 64-bit integer.
 */
typedef struct FFIKeyArray_u64 FFIKeyArrayU64;

/**
 * Arguments passed to the FFI entry point that serialises uncompressed sprite
 * data using 64bit hash keys.
 *
 * This struct is a thin, `#[repr(C)]`‑compatible container that carries
 * pointers and callbacks required by the native (C) side of the library.
 * The public function `serialize_uncompressed_data_u64` validates the
 * pointers, then forwards the data to the generic implementation
 * `serialize_uncompressed_data_internal::<u64>`.
 *
 * # Fields
 *
 * * `manifest_array_ptr` – Pointer to the first element of an array of
 *   `FFIFileManifestParentU64`. Each entry describes a file (its name and the
 *   list of chunk hashes that make up the file). The caller must guarantee
 *   that the array lives for the duration of the call and that the pointer is
 *   non‑null and properly aligned.
 * * `manifest_len` – Number of elements in the `manifest_array_ptr` array.
 * * `user_data` – Opaque pointer that is forwarded unchanged to the callbacks
 *   (`get_keys_cb` and `get_chunks_cb`). It can be used by the caller to
 *   store context such as a handle to a Rust object, a boxed closure, or any
 *   other state required by the callbacks. The pointer must be valid for the
 *   duration of the call and properly aligned.
 * * `get_keys_cb` – Callback that the serializer invokes to obtain the list
 *   of hash keys (i.e., the set of unique 64bit hashes that will be
 *   looked up). The callback must fill `out_keys` with a `FFIKeyArrayU64`
 *   describing the keys and return `FFICallbackStatus::Ok` on success.
 * * `get_chunks_cb` – Callback used to retrieve the actual chunk data for a
 *   batch of hashes supplied by the serializer.
 *   The caller should read `hashes_len` hashes from the `hashes` pointer,
 *   locate the corresponding chunk data, populate `out_chunks`, and return a
 *   status code.
 *
 * # Safety
 *
 *   The fields contain raw pointers and unsafe callbacks. The caller must
 *   ensure that all pointers are non‑null, correctly aligned, and point to
 *   memory that remains valid for the entire duration of the FFI call.
 *   Violating these requirements may lead to undefined behavior.
 */
typedef struct SerializeUncompressedDataArgsU64 {
  const FFIFileManifestParentU64 *manifest_array_ptr;
  uintptr_t manifest_len;
  void *user_data;
  enum FFICallbackStatus (*get_keys_cb)(void *user_data, FFIKeyArrayU64 *out_keys);
  enum FFICallbackStatus (*get_chunks_cb)(void *user_data,
                                          const uint64_t *hashes,
                                          uintptr_t hashes_len,
                                          struct FFIChunkDataArray *out_chunks);
} SerializeUncompressedDataArgsU64;

/**
 * Holds all the serialized data prepared for the archive-building process.
 *
 * This struct is the output of the `serialize_uncompressed_data_ffi_*`
 * functions. It bundles together all the necessary components—the file
 * manifest, the chunk index, and the sorted list of unique hashes—into a
 * single, C-compatible structure. This data is then passed to the
 * `archive_builder_new_*` functions to begin the final archive construction.
 *
 * # Type Parameters
 *
 * * `H`: The generic hash type (e.g., `u64`, `u128`) used throughout the
 *   serialized data.
 *
 * # Fields
 *
 * * `ser_manifest_ptr`: A pointer to an array of [`FFIFileManifestParent`]
 *   structs, representing the complete, sorted file manifest.
 * * `ser_manifest_len`: The number of entries in the `ser_manifest_ptr`
 *   array.
 * * `ser_chunk_index_ptr`: A pointer to an array of [`FFIChunkIndexEntry`]
 *   structs, representing the complete, sorted chunk index.
 * * `ser_chunk_index_len`: The number of entries in the
 *   `ser_chunk_index_ptr` array.
 * * `sorted_hashes_ptr`: A pointer to a contiguous array of all unique chunk
 *   hashes, sorted in a deterministic order.
 * * `sorted_hashes_len`: The number of hashes in the `sorted_hashes_ptr`
 *   array.
 *
 * # Safety
 *
 * The C caller takes full ownership of the memory for this struct and all the
 * arrays it points to. To prevent significant memory leaks, the top-level
 * pointer to this struct **must** be passed to the corresponding
 * `free_serialized_output_*` function once it is no longer needed.
 */
typedef struct FFISerializedOutput_u64 {
  struct FFIFileManifestParent_u64 *ser_manifest_ptr;
  uintptr_t ser_manifest_len;
  uintptr_t ser_manifest_cap;
  struct FFIChunkIndexEntry_u64 *ser_chunk_index_ptr;
  uintptr_t ser_chunk_index_len;
  uintptr_t ser_chunk_index_cap;
  const uint64_t *sorted_hashes_ptr;
  uintptr_t sorted_hashes_len;
  uintptr_t sorted_hashes_cap;
} FFISerializedOutput_u64;

/**
 * An `FFISerializedOutput` struct specialized for `u64` hashes.
 *
 * This type is returned by [`serialize_uncompressed_data_ffi_u64`] and is
 * the expected input for [`free_serialized_output_u64`]. It bundles all the
 * necessary serialized data (manifest, chunk index, sorted hashes) for
 * building an archive where chunks are identified by 64-bit hashes.
 */
typedef struct FFISerializedOutput_u64 FFISerializedOutputU64;

/**
 * FFI-safe struct for passing an array of keys from C to Rust.
 *
 * * `ptr`: A pointer to the first element of a contiguous array of keys.
 * * `len`: Number of elements in the array.
 * * `cap`: Capacity of the allocated array.
 *
 * # Memory Management
 *
 * The C caller allocates the array and the key values.  When this struct is
 * passed to Rust, Rust takes ownership of the buffer and will deallocate
 * it when the `FFIKeyArray` is dropped.  The caller must **not** free the
 * memory after the FFI call returns.
 *
 * # Type Parameters
 *
 * * `H` – hash type (`u64`, `u128`, …).  The key type is generic so the
 *   struct can be specialized for any hash size.
 *
 * # Usage
 *
 * In the serialization FFI, `get_keys_cb` fills a `FFIKeyArray` and the
 * Rust side consumes it with `Vec::from_raw_parts`, yielding a `Vec<H>`
 * that is automatically dropped.  If `len` is zero, `ptr` may be null.
 */
typedef struct FFIKeyArray_U128Bytes {
  struct U128Bytes *ptr;
  uintptr_t len;
  uintptr_t cap;
} FFIKeyArray_U128Bytes;

/**
 * An `FFIKeyArray` specialized for `u128` hashes.
 *
 * This type is used in FFI functions that deal with hash keys where the
 * chunk hash algorithm produces a 128-bit integer, represented on the FFI
 * boundary as a [u8; 16] byte array in a U128Bytes struct.
 */
typedef struct FFIKeyArray_U128Bytes FFIKeyArrayU128;

/**
 * Arguments passed to the FFI entry point that serialises uncompressed sprite
 * data using 128bit hash keys.
 *
 * This struct is a thin, `#[repr(C)]`‑compatible container that carries
 * pointers and callbacks required by the native (C) side of the library.
 * The public function `serialize_uncompressed_data_u128` validates the
 * pointers, then forwards the data to the generic implementation
 * `serialize_uncompressed_data_internal::<u128>`.
 *
 * # Fields
 *
 * * `manifest_array_ptr` – Pointer to the first element of an array of
 *   `FFIFileManifestParentU128`. Each entry describes a file (its name and
 *   the list of chunk hashes that make up the file). The caller must
 *   guarantee that the array lives for the duration of the call and that the
 *   pointer is non‑null and properly aligned.
 * * `manifest_len` – Number of elements in the `manifest_array_ptr` array.
 * * `user_data` – Opaque pointer that is forwarded unchanged to the callbacks
 *   (`get_keys_cb` and `get_chunks_cb`). It can be used by the caller to
 *   store context such as a handle to a Rust object, a boxed closure, or any
 *   other state required by the callbacks. The pointer must be valid for the
 *   duration of the call and properly aligned.
 * * `get_keys_cb` – Callback that the serializer invokes to obtain the list
 *   of hash keys (i.e., the set of unique 128bit hashes that will be
 *   looked up). The callback must fill `out_keys` with a `FFIKeyArrayU128`
 *   describing the keys and return `FFICallbackStatus::Ok` on success.
 * * `get_chunks_cb` – Callback used to retrieve the actual chunk data for a
 *   batch of hashes supplied by the serializer.
 *   The caller should read `hashes_len` hashes from the `hashes` pointer,
 *   locate the corresponding chunk data, populate `out_chunks`, and return a
 *   status code.
 *
 * # Safety
 *
 *   The fields contain raw pointers and unsafe callbacks. The caller must
 *   ensure that all pointers are non‑null, correctly aligned, and point to
 *   memory that remains valid for the entire duration of the FFI call.
 *   Violating these requirements may lead to undefined behavior.
 */
typedef struct SerializeUncompressedDataArgsU128 {
  const FFIFileManifestParentU128 *manifest_array_ptr;
  uintptr_t manifest_len;
  void *user_data;
  enum FFICallbackStatus (*get_keys_cb)(void *user_data, FFIKeyArrayU128 *out_keys);
  enum FFICallbackStatus (*get_chunks_cb)(void *user_data,
                                          const uint8_t *hashes,
                                          uintptr_t hashes_len,
                                          struct FFIChunkDataArray *out_chunks);
} SerializeUncompressedDataArgsU128;

/**
 * Holds all the serialized data prepared for the archive-building process.
 *
 * This struct is the output of the `serialize_uncompressed_data_ffi_*`
 * functions. It bundles together all the necessary components—the file
 * manifest, the chunk index, and the sorted list of unique hashes—into a
 * single, C-compatible structure. This data is then passed to the
 * `archive_builder_new_*` functions to begin the final archive construction.
 *
 * # Type Parameters
 *
 * * `H`: The generic hash type (e.g., `u64`, `u128`) used throughout the
 *   serialized data.
 *
 * # Fields
 *
 * * `ser_manifest_ptr`: A pointer to an array of [`FFIFileManifestParent`]
 *   structs, representing the complete, sorted file manifest.
 * * `ser_manifest_len`: The number of entries in the `ser_manifest_ptr`
 *   array.
 * * `ser_chunk_index_ptr`: A pointer to an array of [`FFIChunkIndexEntry`]
 *   structs, representing the complete, sorted chunk index.
 * * `ser_chunk_index_len`: The number of entries in the
 *   `ser_chunk_index_ptr` array.
 * * `sorted_hashes_ptr`: A pointer to a contiguous array of all unique chunk
 *   hashes, sorted in a deterministic order.
 * * `sorted_hashes_len`: The number of hashes in the `sorted_hashes_ptr`
 *   array.
 *
 * # Safety
 *
 * The C caller takes full ownership of the memory for this struct and all the
 * arrays it points to. To prevent significant memory leaks, the top-level
 * pointer to this struct **must** be passed to the corresponding
 * `free_serialized_output_*` function once it is no longer needed.
 */
typedef struct FFISerializedOutput_U128Bytes {
  struct FFIFileManifestParent_U128Bytes *ser_manifest_ptr;
  uintptr_t ser_manifest_len;
  uintptr_t ser_manifest_cap;
  struct FFIChunkIndexEntry_U128Bytes *ser_chunk_index_ptr;
  uintptr_t ser_chunk_index_len;
  uintptr_t ser_chunk_index_cap;
  const struct U128Bytes *sorted_hashes_ptr;
  uintptr_t sorted_hashes_len;
  uintptr_t sorted_hashes_cap;
} FFISerializedOutput_U128Bytes;

/**
 * An `FFISerializedOutput` struct specialized for `u128` hashes.
 *
 * This type is returned by [`serialize_uncompressed_data_ffi_u128`] and is
 * the expected input for [`free_serialized_output_u128`]. It bundles all the
 * necessary serialized data (manifest, chunk index, sorted hashes) for
 * building an archive where chunks are identified by 128-bit hashes,
 * represented on the FFI boundary as a [u8; 16] byte array in a U128Bytes
 * struct.
 */
typedef struct FFISerializedOutput_U128Bytes FFISerializedOutputU128;

/**
 * The magic number used to identify a sprite-shrink archive file.
 *
 * This 8-byte signature is at the beginning of the file and is used to
 * quickly verify that the file is a valid archive before parsing. The
 * value is "SSARCHV1".
 */
extern const uint8_t MAGIC_NUMBER[8];

/**
 * Creates and initializes a new `ArchiveBuilder` for u64 hashes.
 *
 * This function serves as the entry point for the archive creation process
 * from a C interface. It configures a new builder with the necessary file
 * metadata, a list of all unique chunk hashes, and C callback functions for
 * data retrieval and writing.
 *
 * On success, it returns a pointer to an opaque `ArchiveBuilderU64` handle
 * via the `out_ptr` parameter. This handle can then be used with other FFI
 * functions to configure and finally build the archive.
 *
 * # Arguments
 *
 * * `args`: Struct for all the necessary data for initializing the archive
 *   creation process.
 * * `out_ptr`: A pointer to a `*mut ArchiveBuilderU64` where the handle to
 *   the newly created builder will be written.
 *
 * # Returns
 *
 * * `FFIResult::StatusOk` on success, and `out_ptr` will be populated with a valid
 *   handle.
 * * `FFIResult::NullArgument` if any of the essential pointer arguments
 *   (`manifest_array_ptr`, `sorted_hashes_array_ptr`, `out_ptr`) are null.
 *
 * # Safety
 *
 * The caller is responsible for ensuring the following invariants:
 * * All pointer arguments (`manifest_array_ptr`, `sorted_hashes_array_ptr`,
 *   `out_ptr`) in the `args` parameter must be non‑null and point to valid
 *   memory.
 * * The `ArchiveBuilderU64` handle returned via `out_ptr` is owned by the
 *   C caller and **must** be passed to either `archive_builder_build_u64`
 *   to consume it and build the archive, or `archive_builder_free_u64` to
 *   deallocate its memory if the build process is aborted.  Failure to do so
 *   will result in a memory leak.
 */
SPRITE_SHRINK_MUST_USE
FFIResult archive_builder_new_u64(const struct ArchiveBuilderArgsU64 *args,
                                  struct ArchiveBuilderU64 **out_ptr);

/**
 * Creates and initializes a new `ArchiveBuilder` for u128 hashes.
 *
 * This function serves as the entry point for the archive creation process
 * from a C interface. It configures a new builder with the necessary file
 * metadata, a list of all unique chunk hashes, and C callback functions for
 * data retrieval and writing.
 *
 * On success, it returns a pointer to an opaque `ArchiveBuilderU128` handle
 * via the `out_ptr` parameter. This handle can then be used with other FFI
 * functions to configure and finally build the archive.
 *
 * # Arguments
 *
 * * `args`: Struct for all the necessary data for initializing the archive
 *   creation process.
 * * `out_ptr`: A pointer to a `*mut ArchiveBuilderU128` where the handle to
 *   the newly created builder will be written.
 *
 * # Returns
 *
 * * `FFIResult::StatusOk` on success, and `out_ptr` will be populated with a valid
 *   handle.
 * * `FFIResult::NullArgument` if any of the essential pointer arguments
 *   (`manifest_array_ptr`, `sorted_hashes_array_ptr`, `out_ptr`) are null.
 *
 * # Safety
 *
 * The caller is responsible for ensuring the following invariants:
 * * All pointer arguments (`manifest_array_ptr`, `sorted_hashes_array_ptr`,
 *   `out_ptr`) in the `args` parameter must be non‑null and point to valid
 *   memory.
 * * The `ArchiveBuilderU128` handle returned via `out_ptr` is owned by the
 *   C caller and **must** be passed to either `archive_builder_build_u128`
 *   to consume it and build the archive, or `archive_builder_free_u128` to
 *   deallocate its memory if the build process is aborted.  Failure to do so
 *   will result in a memory leak.
 */
SPRITE_SHRINK_MUST_USE
FFIResult archive_builder_new_u128(const struct ArchiveBuilderArgsU128 *args,
                                   struct ArchiveBuilderU128 **out_ptr);

/**
 * Decompress a chunk of data using a zstd dictionary.
 *
 * # Safety
 *
 * This function is unsafe because it dereferences raw pointers supplied by
 * callers from other languages (e.g., C). The caller must guarantee:
 *
 * * `comp_chunk_data_ptr` points to a valid buffer of at least
 *   `comp_chunk_data_len` bytes.
 * * `dictionary_ptr` points to a valid buffer of at least `dictionary_len`
 *   bytes.
 * * `data_out_ptr` points to a mutable buffer of at least `data_out_len`
 *   bytes.
 *
 * If any of the pointers are null, the function returns
 * `FFIResult::NullArgument`.
 *
 * # Parameters
 *
 * - `comp_chunk_data_ptr`: Pointer to the compressed chunk data.
 * - `comp_chunk_data_len`: Length of the compressed data buffer.
 * - `dictionary_ptr`: Pointer to the dictionary used for decompression.
 * - `dictionary_len`: Length of the dictionary buffer.
 * - `data_out_ptr`: Pointer to the buffer where decompressed data will be
 *   written.
 * - `data_out_len`: Capacity of the output buffer. This is known prior to
 *   calling this function as it is stored as part of the chunk's metadata.
 *
 * # Return Value
 *
 * The function returns an `FFIResult` indicating the outcome:
 *
 * * `FFIResult::StatusOk`: Decompression succeeded and the output was
 *   written.
 * * `FFIResult::NullArgument`: One or more supplied pointers were null.
 * * `FFIResult::BufferTooSmall`: The output buffer is not large enough to
 *   hold the decompressed data.
 * * `FFIResult::InternalError`: Decompression failed for an internal reason
 *   (e.g., invalid data).
 *
 * # Remarks
 *
 * This wrapper converts raw pointers into Rust slices, calls the safe
 * `decompress_chunk` function, and copies the resulting data into the caller‑provided
 * output buffer. All pointer checks and length validations are performed before any
 * unsafe operations
 */
SPRITE_SHRINK_MUST_USE
FFIResult decompress_chunk_c(const uint8_t *comp_chunk_data_ptr,
                             uintptr_t comp_chunk_data_len,
                             const uint8_t *dictionary_ptr,
                             uintptr_t dictionary_len,
                             uint8_t *data_out_ptr,
                             uintptr_t data_out_len);

/**
 * Sets the compression algorithm on the ArchiveBuilder for a u64 hash.
 *
 * # Safety
 * The `builder_handle` must be a valid, non-null pointer from
 * `archive_builder_new_u64`.
 */
SPRITE_SHRINK_MUST_USE
FFIResult archive_builder_set_compression_algorithm_u64(struct ArchiveBuilderU64 *builder_handle,
                                                        uint16_t code);

/**
 * Sets the compression algorithm on the ArchiveBuilder for a u128 hash.
 *
 * # Safety
 * The `builder_handle` must be a valid, non-null pointer from
 * `archive_builder_new_u128`.
 */
SPRITE_SHRINK_MUST_USE
FFIResult archive_builder_set_compression_algorithm_u128(struct ArchiveBuilderU128 *builder_handle,
                                                         uint16_t code);

/**
 * Sets the compression level on the ArchiveBuilder for a u64 hash.
 *
 * # Safety
 * The `builder_handle` must be a valid, non-null pointer from
 * `archive_builder_new_u64`.
 */
SPRITE_SHRINK_MUST_USE
FFIResult archive_builder_set_compression_level_u64(struct ArchiveBuilderU64 *builder_handle,
                                                    int32_t level);

/**
 * Sets the compression level on the ArchiveBuilder for a u128 hash.
 *
 * # Safety
 * The `builder_handle` must be a valid, non-null pointer from
 * `archive_builder_new_u128`.
 */
SPRITE_SHRINK_MUST_USE
FFIResult archive_builder_set_compression_level_u128(struct ArchiveBuilderU128 *builder_handle,
                                                     int32_t level);

/**
 * Sets the dictionary size on the ArchiveBuilder for a u64 hash.
 *
 * # Safety
 * The `builder_handle` must be a valid, non-null pointer from
 * `archive_builder_new_u64`.
 */
SPRITE_SHRINK_MUST_USE
FFIResult archive_builder_set_dictionary_size_u64(struct ArchiveBuilderU64 *builder_handle,
                                                  uint64_t size);

/**
 * Sets the dictionary size on the ArchiveBuilder for a u128 hash.
 *
 * # Safety
 * The `builder_handle` must be a valid, non-null pointer from
 * `archive_builder_new_u128`.
 */
SPRITE_SHRINK_MUST_USE
FFIResult archive_builder_set_dictionary_size_u128(struct ArchiveBuilderU128 *builder_handle,
                                                   uint64_t size);

/**
 * Sets the worker count on the ArchiveBuilder for a u64 hash.
 *
 * # Safety
 * The `builder_handle` must be a valid, non-null pointer from
 * `archive_builder_new_u64`.
 */
SPRITE_SHRINK_MUST_USE
FFIResult archive_builder_set_worker_count_u64(struct ArchiveBuilderU64 *builder_handle,
                                               uintptr_t threads);

/**
 * Sets the worker count on the ArchiveBuilder for a u128 hash.
 *
 * # Safety
 * The `builder_handle` must be a valid, non-null pointer from
 * `archive_builder_new_u128`.
 */
SPRITE_SHRINK_MUST_USE
FFIResult archive_builder_set_worker_count_u128(struct ArchiveBuilderU128 *builder_handle,
                                                uintptr_t threads);

/**
 * Sets the optimize dictionary flag on the ArchiveBuilder for a u64 hash.
 *
 * # Safety
 * The `builder_handle` must be a valid, non-null pointer from
 * `archive_builder_new_u64`.
 */
SPRITE_SHRINK_MUST_USE
FFIResult archive_builder_set_optimize_dictionary_u64(struct ArchiveBuilderU64 *builder_handle,
                                                      bool optimize);

/**
 * Sets the optimize dictionary flag on the ArchiveBuilder for a u128 hash.
 *
 * # Safety
 * The `builder_handle` must be a valid, non-null pointer from
 * `archive_builder_new_u128`.
 */
SPRITE_SHRINK_MUST_USE
FFIResult archive_builder_set_optimize_dictionary_u128(struct ArchiveBuilderU128 *builder_handle,
                                                       bool optimize);

/**
 * Sets the progress callback for the ArchiveBuilder for a u64 hash.
 *
 * # Safety
 * The `builder_handle` must be a valid pointer returned from
 * `archive_builder_new_u64`. The `callback` function pointer must be
 * valid for the lifetime of the builder.
 */
SPRITE_SHRINK_MUST_USE
FFIResult archive_builder_set_c_progress_u64(struct ArchiveBuilderU64 *builder_handle,
                                             void (*callback)(struct FFIProgress, void*),
                                             void *user_data);

/**
 * Sets the progress callback for the ArchiveBuilder for a u128 hash.
 *
 * # Safety
 * The `builder_handle` must be a valid pointer returned from
 * `archive_builder_new_u128`. The `callback` function pointer must be
 * valid for the lifetime of the builder.
 */
SPRITE_SHRINK_MUST_USE
FFIResult archive_builder_set_c_progress_u128(struct ArchiveBuilderU128 *builder_handle,
                                              void (*callback)(struct FFIProgress, void*),
                                              void *user_data);

/**
 * Consumes the u64 builder, builds the archive, and returns the data via
 * an out-parameter for a u64 hash.
 *
 * # Safety
 * - `builder_handle` must be a valid pointer from
 *   `archive_builder_new_u64`.
 * - `out_data` must be a valid pointer to an `*mut FFIArchiveData`.
 * - This function consumes the builder; `builder_handle` is invalid
 *   after this call.
 * - The pointer returned via `out_data` must be freed with
 *   `archive_data_free_u64`
 */
SPRITE_SHRINK_MUST_USE
FFIResult archive_builder_build_u64(struct ArchiveBuilderU64 *builder_handle,
                                    struct FFIArchiveData **out_ptr);

/**
 * Consumes the u128 builder, builds the archive, and returns the data via
 * an out-parameter for a u128 hash.
 *
 * # Safety
 * - `builder_handle` must be a valid pointer from
 *   `archive_builder_new_u128`.
 * - `out_data` must be a valid pointer to an `*mut FFIArchiveData`.
 * - This function consumes the builder; `builder_handle` is invalid
 *   after this call.
 * - The pointer returned via `out_data` must be freed with
 *   `archive_data_free_u128`
 */
SPRITE_SHRINK_MUST_USE
FFIResult archive_builder_build_u128(struct ArchiveBuilderU128 *builder_handle,
                                     struct FFIArchiveData **out_ptr);

/**
 * Frees the ArchiveBuilder if the build is never run for u64 hashes.
 *
 * # Safety
 * The `builder_handle` must be a valid pointer from
 * `archive_builder_new_u64` that has not been passed to
 * `archive_builder_build_u64`.
 */
void archive_builder_free_u64(struct ArchiveBuilderU64 *builder_handle);

/**
 * Frees the ArchiveBuilder if the build is never run for u128 hashes.
 *
 * # Safety
 * The `builder_handle` must be a valid pointer from
 * `archive_builder_new_u128` that has not been passed to
 * `archive_builder_build_u128`.
 */
void archive_builder_free_u128(struct ArchiveBuilderU128 *builder_handle);

/**
 * Frees the data returned by a successful build.
 *
 * # Safety
 * The `archive_data_ptr` must be a valid pointer from
 * `archive_builder_build`.
 */
void archive_data_free(struct FFIArchiveData *archive_data_ptr);

/**
 * Parses the file chunk index from a raw byte slice.
 *
 * On success, returns `FFIResult::StatusOk` and populates `out_ptr`.
 * On failure, returns an appropriate error code.
 *
 * # Safety
 * - `chunk_index_array_ptr` must point to a valid, readable memory block of
 *   `chunk_index_len` bytes.
 * - `out_ptr` must be a valid, non-null pointer to a `*mut
 *   FFIParsedChunkIndexArrayU64`.
 * - On success, the pointer written to `out_ptr` is owned by the C
 *   caller and MUST be freed by passing it to
 *   `free_parsed_chunk_index_u64` to avoid memory leaks.
 */
SPRITE_SHRINK_MUST_USE
FFIResult parse_file_chunk_index_u64(const uint8_t *chunk_index_array_ptr,
                                     uintptr_t chunk_index_len,
                                     FFIParsedChunkIndexArrayU64 **out_ptr);

/**
 * Parses the file chunk index from a raw byte slice.
 *
 * On success, returns `FFIResult::StatusOk` and populates `out_ptr`.
 * On failure, returns an appropriate error code.
 *
 * # Safety
 * - `chunk_index_array_ptr` must point to a valid, readable memory block of
 *   `chunk_index_len` bytes.
 * - `out_ptr` must be a valid, non-null pointer to a `*mut
 *   FFIParsedChunkIndexArrayU128`.
 * - On success, the pointer written to `out_ptr` is owned by the C
 *   caller and MUST be freed by passing it to
 *   `free_parsed_chunk_index_u128` to avoid memory leaks.
 */
SPRITE_SHRINK_MUST_USE
FFIResult parse_file_chunk_index_u128(const uint8_t *chunk_index_array_ptr,
                                      uintptr_t chunk_index_len,
                                      FFIParsedChunkIndexArrayU128 **out_ptr);

/**
 * Frees the memory allocated by `parse_file_chunk_index_u64`.
 *
 * # Safety
 * The `ptr` must be a non-null pointer from a successful call to
 * `parse_file_chunk_index_u64`.
 */
void free_parsed_chunk_index_u64(FFIParsedChunkIndexArrayU64 *ptr);

/**
 * Frees the memory allocated by `parse_file_chunk_index_ffi_u128`.
 *
 * # Safety
 * The `ptr` must be a non-null pointer from a successful call to
 * `parse_file_chunk_index_u128`.
 */
void free_parsed_chunk_index_u128(FFIParsedChunkIndexArrayU128 *ptr);

/**
 * Parses a file header from a byte slice.
 *
 * On success, returns `FFIResult::StatusOk` and populates `out_ptr`.
 * On failure, returns an appropriate error code.
 *
 * # Safety
 * - `header_data_array_ptr` must point to valid memory of at least
 *   `header_data_len` bytes.
 * - `out_ptr` must be a valid pointer to a `*mut FileHeader`.
 * - The pointer returned via `out_ptr` is owned by the caller and MUST be
 *   freed by passing it to `free_file_header_ffi`.
 */
SPRITE_SHRINK_MUST_USE
FFIResult parse_file_header_ffi(const uint8_t *header_data_array_ptr,
                                uintptr_t header_data_len,
                                struct FileHeader **out_ptr);

/**
 * Frees the memory for a FileHeader that was allocated by
 * `parse_file_header_ffi`.
 *
 * # Safety
 * The `ptr` must be a pointer returned from a successful call to
 * `parse_file_header_ffi`. Calling this function with a null pointer or a
 * pointer that has already been freed will lead to undefined behavior.
 */
void free_file_header(struct FileHeader *ptr);

/**
 * Parses the file manifest from a raw byte slice for a u64 hash.
 *
 * On success, returns `FFIResult::StatusOk` and populates `out_ptr`.
 * On failure, returns an appropriate error code.
 *
 * # Safety
 * - `manifest_data_array_ptr` must point to valid memory of at least
 *   `manifest_data_len` bytes.
 * - `out_ptr` must be a valid pointer to a `*mut
 *   FFIParsedManifestArrayU64`.
 * - The pointer returned via `out_ptr` is owned by the caller and
 *   MUST be freed by passing it to `free_parsed_manifest_u64`.
 */
SPRITE_SHRINK_MUST_USE
FFIResult parse_file_metadata_u64(const uint8_t *manifest_data_array_ptr,
                                  uintptr_t manifest_data_len,
                                  FFIParsedManifestArrayU64 **out_ptr);

/**
 * Parses the file manifest from a raw byte slice for a u128 hash.
 *
 * On success, returns `FFIResult::StatusOk` and populates `out_ptr`.
 * On failure, returns an appropriate error code.
 *
 * # Safety
 * - `manifest_data_array_ptr` must point to valid memory of at least
 *   `manifest_data_len` bytes.
 * - `out_ptr` must be a valid pointer to a `*mut
 *   FFIParsedManifestArrayU128`.
 * - The pointer returned via `out_ptr` is owned by the caller and
 *   MUST be freed by passing it to `free_parsed_manifest_u128`.
 */
SPRITE_SHRINK_MUST_USE
FFIResult parse_file_metadata_u128(const uint8_t *manifest_data_array_ptr,
                                   uintptr_t manifest_data_len,
                                   FFIParsedManifestArrayU128 **out_ptr);

/**
 * Frees the memory allocated by `parse_file_metadata_u64`.
 *
 * # Safety
 * The `ptr` must be a non-null pointer returned from a successful
 * call to `parse_file_metadata_ffi_u64`.
 */
void free_parsed_manifest_u64(FFIParsedManifestArrayU64 *ptr);

/**
 * Frees the memory allocated by `parse_file_metadata_u128`.
 *
 * # Safety
 * The `ptr` must be a non-null pointer returned from a successful
 * call to `parse_file_metadata_u128`.
 */
void free_parsed_manifest_u128(FFIParsedManifestArrayU128 *ptr);

/**
 * Deserializes a raw byte slice into a `HashMap` for rapid chunk lookups
 * and returns an opaque pointer to it as a handle.
 *
 * This function takes the binary data of a chunk index, parses it, and
 * creates an in-memory `HashMap`. It then allocates this map on the heap
 * and provides a handle (a raw pointer) to the C caller. This handle can
 * be passed to `lookup_chunk_location_u64` to perform fast lookups.
 *
 * On success, returns `FFIResult::StatusOk` and writes the handle to `map_ptr`.
 * On failure, it returns an appropriate error code.
 *
 * # Arguments
 *
 * * `chunk_index_data_ptr`: A pointer to the raw byte data of the chunk index.
 * * `chunk_index_data_len`: The length of the byte data.
 * * `map_ptr`: An out-parameter; a pointer to a `*mut c_void` where the handle
 *   to the created `HashMap` will be written.
 *
 * # Safety
 *
 * - `chunk_index_data_ptr` must point to a valid, readable memory block of
 *   `chunk_index_data_len` bytes.
 * - `map_ptr` must be a valid, non-null pointer.
 * - The handle written to `map_ptr` on success is owned by the C caller and
 *   MUST be freed by passing it to `free_chunk_index_u64` to avoid
 *   memory leaks.
 * - The handle must not be used after it has been freed.
 */
SPRITE_SHRINK_MUST_USE
FFIResult prepare_chunk_index_u64(const uint8_t *chunk_index_data_ptr,
                                  uintptr_t chunk_index_data_len,
                                  void *map_ptr);

/**
 * Deserializes a raw byte slice into a `HashMap` for rapid chunk lookups
 * and returns an opaque pointer to it as a handle.
 *
 * This function takes the binary data of a chunk index, parses it, and
 * creates an in-memory `HashMap`. It then allocates this map on the heap
 * and provides a handle (a raw pointer) to the C caller. This handle can
 * be passed to `lookup_chunk_location_u128` to perform fast lookups.
 *
 * On success, returns `FFIResult::StatusOk` and writes the handle to `map_ptr`.
 * On failure, it returns an appropriate error code.
 *
 * # Arguments
 *
 * * `chunk_index_data_ptr`: A pointer to the raw byte data of the chunk index.
 * * `chunk_index_data_len`: The length of the byte data.
 * * `map_ptr`: An out-parameter; a pointer to a `*mut c_void` where the handle
 *   to the created `HashMap` will be written.
 *
 * # Safety
 *
 * - `chunk_index_data_ptr` must point to a valid, readable memory block of
 *   `chunk_index_data_len` bytes.
 * - `map_ptr` must be a valid, non-null pointer.
 * - The handle written to `map_ptr` on success is owned by the C caller and
 *   MUST be freed by passing it to `free_chunk_index_u128` to avoid
 *   memory leaks.
 * - The handle must not be used after it has been freed.
 */
SPRITE_SHRINK_MUST_USE
FFIResult prepare_chunk_index_u128(const uint8_t *chunk_index_data_ptr,
                                   uintptr_t chunk_index_data_len,
                                   void *map_ptr);

/**
 * Frees the memory for a chunk index handle created by
 * `prepare_chunk_index_u64`.
 *
 * This function takes the opaque pointer (handle) to the `HashMap` and
 * safely deallocates its memory.
 *
 * # Safety
 *
 * - The `map_ptr` must be a valid handle returned from a successful call to
 *   `prepare_chunk_index_u64`.
 * - The `map_ptr` must not have been freed already. Calling this function
 *   more than once on the same handle will result in a double-free, leading
 *   to undefined behavior.
 * - The `map_ptr` must not be used again after this function is called.
 */
void free_chunk_index_u64(void *map_ptr);

/**
 * Frees the memory for a chunk index handle created by
 * `prepare_chunk_index_u128`.
 *
 * This function takes the opaque pointer (handle) to the `HashMap` and
 * safely deallocates its memory.
 *
 * # Safety
 *
 * - The `map_ptr` must be a valid handle returned from a successful call to
 *   `prepare_chunk_index_u128`.
 * - The `map_ptr` must not have been freed already. Calling this function
 *   more than once on the same handle will result in a double-free, leading
 *   to undefined behavior.
 * - The `map_ptr` must not be used again after this function is called.
 */
void free_chunk_index_u128(void *map_ptr);

/**
 * Creates a file manifest and a list of data chunks via an FFI‑safe interface
 * for 64‑bit hash keys.
 *
 * The function parses the supplied file name, data slice, and chunk
 * descriptors and produces an `FFIFileManifestChunksU64` that the C
 * caller can consume.  The returned object owns all memory needed for the
 * manifest and the chunks; the caller must free it with
 * `free_file_manifest_and_chunks_u64`.
 *
 * # Arguments
 *
 * * `args`: A POD container that bundles a C‑string file name, a raw data
 *   slice, and an array of `FFIChunk` descriptors  and their lengths)
 * * `out_ptr`: non‑null pointer to a mutable `*mut
 *   FFIFileManifestChunksU64` where the result will be stored.
 *
 * # Returns
 *
 * * `FFIResult::StatusOk` - `*out_ptr` now points to a valid
 *   `FFIFileManifestChunksU64`
 * * `FFIResult::NullArgument` - any of the pointers above were `NULL`
 *
 * # Safety
 *
 * The caller must guarantee that:
 * * All pointers refer to valid, readable memory for the stated lengths.
 * * `out_ptr` is a valid, non‑null pointer that the caller will read after
 *   the call.
 * * The returned struct and all nested data are allocated on the heap; the
 *   caller is responsible for freeing it with
 *   `free_file_manifest_and_chunks_u64` to avoid leaks.
 */
SPRITE_SHRINK_MUST_USE
FFIResult create_file_manifest_and_chunks_u64(const struct CreateFileManifestAndChunksArgs *args,
                                              FFIFileManifestChunksU64 **out_ptr);

/**
 * Creates a file manifest and a list of data chunks via an FFI‑safe interface
 * for 128‑bit hash keys.
 *
 * The arguments and semantics are identical to
 * `create_file_manifest_and_chunks_u64`, but the resulting struct is
 * `FFIFileManifestChunksU128`.  The caller must free the returned value
 * with `free_file_manifest_and_chunks_u128`.
 *
 * # Arguments
 *
 * * `args`: A POD container that bundles a C‑string file name, a raw data
 *   slice, and an array of `FFIChunk` descriptors  and their lengths).
 * * `out_ptr` – non‑null pointer to a mutable `*mut
 *   FFIFileManifestChunksU128` where the result will be stored.
 *
 * # Returns
 *
 * * `FFIResult::StatusOk` – `*out_ptr` now points to a valid
 *   `FFIFileManifestChunksU128`
 * * `FFIResult::NullArgument` – any of the pointers above were `NULL`
 *
 * # Safety
 *
 * The caller must guarantee that:
 * * All pointers refer to valid, readable memory for the stated lengths.
 * * `out_ptr` is a valid, non‑null pointer that the caller will read after
 *   the call.
 * * The returned struct and all nested data are allocated on the heap; the
 *   caller is responsible for freeing it with
 *   `free_file_manifest_and_chunks_u128` to avoid leaks.
 */
SPRITE_SHRINK_MUST_USE
FFIResult create_file_manifest_and_chunks_u128(const struct CreateFileManifestAndChunksArgs *args,
                                               FFIFileManifestChunksU128 **out_ptr);

/**
 * Frees the memory allocated by `create_file_manifest_and_chunk_u64`
 * for a u64 hash.
 *
 * # Safety
 * The caller MUST ensure that `ptr` is a valid pointer returned from
 * `create_file_manifest_and_chunks_u64` and that it is not used
 * after this call. This function should only be called once for any
 * given pointer.
 */
void free_file_manifest_and_chunks_u64(FFIFileManifestChunksU64 *ptr);

/**
 * Frees the memory allocated by `create_file_manifest_and_chunks_u128`
 * for a u128 hash.
 *
 * # Safety
 * The caller MUST ensure that `ptr` is a valid pointer returned from
 * `create_file_manifest_and_chunks_u128` and that it is not used
 * after this call. This function should only be called once for any
 * given pointer.
 */
void free_file_manifest_and_chunks_u128(FFIFileManifestChunksU128 *ptr);

/**
 * Processes a single file from memory via an FFI-safe interface.
 *
 * On success, returns `FFIResult::StatusOk` and populates `out_ptr`.
 *
 * # Safety
 * - `file_data` must be valid for reads. Its pointers must not be null.
 * - `out_ptr` must be a valid, non-null pointer to a
 *   `*mut FFIProcessedFileData`.
 * - On success, the pointer written to `out_ptr` is owned by the caller and
 *   MUST be freed by passing it to `free_processed_file_data_ffi`.
 */
SPRITE_SHRINK_MUST_USE
FFIResult process_file_in_memory_ffi(struct FFIFileData file_data,
                                     uint64_t window_size,
                                     struct FFIProcessedFileData **out_ptr);

/**
 * Frees the memory allocated by `process_file_in_memory_ffi`.
 *
 * # Safety
 * The caller MUST ensure that `ptr` is a valid pointer returned from
 * `process_file_in_memory_ffi` and that it is not used after this call.
 * This function should only be called once for any given pointer.
 */
void free_processed_file_data_ffi(struct FFIProcessedFileData *ptr);

/**
 * Verify a single file by reconstructing it from stored chunks and checking its
 * verification hash.
 *
 * This is the FFI‑exposed entry point for 64‑bit hash types. It expects a
 * pointer to a `VerifySingleFileArgsU64` struct that bundles all required
 * arguments and callbacks. The function is `unsafe` because it dereferences
 * raw pointers that cross the FFI boundary.
 *
 * # Parameters
 *
 * * `args` – Pointer to a fully‑initialised `VerifySingleFileArgsU64`
 *   containing all required arguments.
 *
 * # Safety
 *
 * * All pointer arguments **must** be non‑null and point to valid memory that
 *   lives at least for the duration of the call.
 * * The `get_chunks_cb` must not unwind across the FFI boundary and must return a
 *   correctly‑populated `FFIChunkDataArray`.
 *
 * If any pointer is null, the function returns `FFIResult::NullArgument`.
 *
 * # Return Value
 *
 * Returns an `FFIResult` indicating success (`FFIResult::StatusOk`) or the type of
 * failure (e.g., `NullArgument`, `InvalidArgument`, or an internal error).
 */
SPRITE_SHRINK_MUST_USE FFIResult verify_single_file_u64(const struct VerifySingleFileArgsU64 *args);

/**
 * Verify a single file by reconstructing it from stored chunks and checking
 * its verification hash.
 *
 * This is the FFI‑exposed entry point for 128‑bit hash types. It expects a
 * pointer to a `VerifySingleFileArgsU128` struct (see `ffi_types.rs`) that
 * bundles all required arguments and callbacks. The function is `unsafe`
 * because it dereferences raw pointers that cross the FFI boundary.
 *
 * # Parameters
 *
 * * `args` – Pointer to a fully‑initialised `VerifySingleFileArgsU128`
 *   containing all required arguments.
 *
 * # Safety
 *
 * * All pointer arguments **must** be non‑null and point to valid memory that
 *   lives at least for the duration of the call.
 * * The `get_chunks_cb` must not unwind across the FFI boundary and must
 *   return a correctly‑populated `FFIChunkDataArray`.
 *
 * If any pointer is null, the function returns `FFIResult::NullArgument`.
 *
 * # Return Value
 *
 * Returns an `FFIResult` indicating success (`FFIResult::StatusOk`) or the type of
 * failure (e.g., `NullArgument`, `InvalidArgument`, or an internal error).
 */
SPRITE_SHRINK_MUST_USE
FFIResult verify_single_file_u128(const struct VerifySingleFileArgsU128 *args);

/**
 * Estimates the compressed size of a data store when using
 * u64 hashes.
 *
 * On success, returns `FFIResult::StatusOk` and populates `out_size`.
 *
 * # Safety
 * - All input pointers must be non-null and valid for their specified
 *   lengths.
 * - `out_size` must be a valid, non-null pointer to a `u64`.
 */
SPRITE_SHRINK_MUST_USE
FFIResult test_compression_u64(const TestCompressionArgsU64 *args,
                               uint64_t *out_size);

/**
 * Estimates the compressed size of a data store when using
 * u128 hashes.
 *
 * On success, returns `FFIResult::StatusOk` and populates `out_size`.
 *
 * # Safety
 * - All input pointers must be non-null and valid for their specified
 *   lengths.
 * - `out_size` must be a valid, non-null pointer to a `u64`.
 */
SPRITE_SHRINK_MUST_USE
FFIResult test_compression_u128(const TestCompressionArgsU128 *args,
                                uint64_t *out_size);

/**
 * Calculates which chunks are needed for a seek operation via an
 * FFI-safe interface.
 *
 * # Safety
 * - `file_manifest_parent` must be a valid, non-null pointer.
 * - `out_ptr` must be a valid pointer to a
 *   `*mut FFISeekInfoArray...`.
 * - On success, the pointer written to `out_ptr` is owned by the C
 *   caller and MUST be freed by passing it to the
 *   `free_seek_chunks_u64` function.
 */
SPRITE_SHRINK_MUST_USE
FFIResult get_seek_chunks_u64(const FFIFileManifestParentU64 *file_manifest_parent,
                              uint64_t seek_offset,
                              uint64_t seek_length,
                              FFISeekInfoArrayU64 **out_ptr);

/**
 * Calculates which chunks are needed for a seek operation via an
 * FFI-safe interface.
 *
 * # Safety
 * - `file_manifest_parent` must be a valid, non-null pointer.
 * - `out_ptr` must be a valid pointer to a
 *   `*mut FFISeekInfoArray...`.
 * - On success, the pointer written to `out_ptr` is owned by the C
 *   caller and MUST be freed by passing it to the
 *   `free_seek_chunks_u128` function.
 */
SPRITE_SHRINK_MUST_USE
FFIResult get_seek_chunks_u128(const FFIFileManifestParentU128 *file_manifest_parent,
                               uint64_t seek_offset,
                               uint64_t seek_length,
                               FFISeekInfoArrayU128 **out_ptr);

/**
 * Frees the memory allocated by the `get_seek_chunks_u64` function.
 *
 * # Safety
 * The `ptr` must be a non-null pointer returned from a successful
 * call to the `get_seek_chunks_u64` function.
 * Calling this with a null pointer or a pointer that has already
 * been freed will lead to undefined behavior.
 */
void free_seek_chunks_u64(FFISeekInfoArrayU64 *ptr);

/**
 * Frees the memory allocated by a `get_seek_chunks_u128` function.
 *
 * # Safety
 * The `ptr` must be a non-null pointer returned from a successful
 * call to the `get_seek_chunks_u128` function.
 * Calling this with a null pointer or a pointer that has already
 * been freed will lead to undefined behavior.
 */
void free_seek_chunks_u128(FFISeekInfoArrayU128 *ptr);

/**
 * Looks up the location of a data chunk in the chunk index using a u64 hash.
 *
 * This function uses an opaque handle to the `HashMap` (created by
 * `prepare_chunk_index_u64`) to find the `FFIChunkLocation` corresponding
 * to the provided hash.
 *
 * On success (`FFIResult::StatusOk`), the `chunk_location` out-parameter is
 * populated with the result. If the hash is not found, the function returns
 * `FFIResult::HashNotFound`.
 *
 * # Arguments
 *
 * * `map_ptr`: An opaque handle to the chunk index `HashMap`, originally
 *   obtained from `prepare_chunk_index_u64`.
 * * `key_hash`: The `u64` hash of the chunk to look up.
 * * `chunk_location`: An out-parameter; a pointer to an `FFIChunkLocation`
 *   struct where the result will be written.
 *
 * # Safety
 *
 * - `map_ptr` must be a valid, non-null handle that has not yet been freed.
 * - `chunk_location` must be a valid, non-null pointer to a writable memory
 *   location capable of holding an `FFIChunkLocation`.
 */
SPRITE_SHRINK_MUST_USE
FFIResult lookup_chunk_location_u64(const void *map_ptr,
                                    uint64_t key_hash,
                                    struct FFIChunkLocation *chunk_location);

/**
 * Looks up the location of a data chunk in the chunk index using a u128 hash.
 *
 * This function uses an opaque handle to the `HashMap` (created by
 * `prepare_chunk_index_u128`) to find the `FFIChunkLocation` corresponding
 * to the provided hash.
 *
 * On success (`FFIResult::StatusOk`), the `chunk_location` out-parameter is
 * populated with the result. If the hash is not found, the function returns
 * `FFIResult::HashNotFound`.
 *
 * # Arguments
 *
 * * `map_ptr`: An opaque handle to the chunk index `HashMap`, originally
 *   obtained from `prepare_chunk_index_u128`.
 * * `key_hash`: A 16-byte array representing the `u128` hash of the chunk
 *   to look up.
 * * `chunk_location`: An out-parameter; a pointer to an `FFIChunkLocation`
 *   struct where the result will be written.
 *
 * # Safety
 *
 * - `map_ptr` must be a valid, non-null handle that has not yet been freed.
 * - `chunk_location` must be a valid, non-null pointer to a writable memory
 *   location capable of holding an `FFIChunkLocation`.
 */
SPRITE_SHRINK_MUST_USE
FFIResult lookup_chunk_location_u128(const void *map_ptr,
                                     const uint8_t *key_hash_ptr,
                                     struct FFIChunkLocation *chunk_location);

/**
 * Serialises uncompressed sprite data using 64bit hash keys.
 *
 * Function for obtaining a `FFISerializedOutputU64` containing a manifest, a
 * chunk index and a sorted hash list. The function validates its arguments
 * and then forwards the work to the generic implementation
 * `serialize_uncompressed_data_internal::<u64>`.
 *
 * # Parameters
 *
 * * `args` – A pointer to a fully‑initialised
 *   `SerializeUncompressedDataArgsU64` structure. The structure supplies the
 *   manifest, user data and the two callbacks required for the serialisation
 *   process.
 * * `out_ptr` – A mutable pointer that will be populated with a pointer to a
 *   newly allocated `FFISerializedOutputU64` on success. The caller is
 *   responsible for freeing this output via the matching
 *   `free_serialized_output_u64` function.
 *
 * # Safety
 *
 * * Both `args` and `out_ptr` must be non‑null pointers. If either is null,
 *   the function returns `FFIResult::NullArgument`.
 * * All pointer arguments **must** be non‑null and point to valid memory that
 *   lives at least for the duration of the call.
 * * `args.manifest_array_ptr` must also be a valid, non‑null pointer to an
 *   array of `FFIFileManifestParentU64` with `args.manifest_len` elements.
 *   The caller is responsible for ensuring the array lives for the duration
 *   of the call.
 * * The callbacks contained in `args` (`get_keys_cb` and `get_chunks_cb`) are
 *   `unsafe extern "C"` functions; they must obey the contract described in
 *   `SerializeUncompressedDataArgsU64`.
 *
 * # Return value
 *
 * Returns an `FFIResult` indicating the outcome:
 *
 * * `FFIResult::StatusOk` – The operation succeeded and `*out_ptr` now points to a
 *   valid `FFISerializedOutputU64`.
 * * `FFIResult::NullArgument` – Either `args` or `out_ptr` (or the manifest
 *   pointer inside `args`) was null.
 * * Other error variants may be returned by the internal implementation if,
 *   for example, a callback fails or memory allocation aborts.
 */
SPRITE_SHRINK_MUST_USE
FFIResult serialize_uncompressed_data_u64(const struct SerializeUncompressedDataArgsU64 *args,
                                          FFISerializedOutputU64 **out_ptr);

/**
 * Serialises uncompressed sprite data using 128bit hash keys.
 *
 * Function for obtaining a `FFISerializedOutputU128` containing a manifest, a
 * chunk index and a sorted hash list. The function validates its arguments
 * and then forwards the work to the generic implementation
 * `serialize_uncompressed_data_internal::<u128>`.
 *
 * # Parameters
 *
 * * `args`: A pointer to a fully‑initialised
 *   `SerializeUncompressedDataArgsU128` structure. The structure supplies the
 *   manifest, user data and the two callbacks required for the serialisation
 *   process.
 * * `out_ptr`: A mutable pointer that will be populated with a pointer to a
 *   newly allocated `FFISerializedOutputU128` on success. The caller is
 *   responsible for freeing this output via the matching
 *   `free_serialized_output_u128` function.
 *
 * # Safety
 *
 * * Both `args` and `out_ptr` must be non‑null pointers. If either is null,
 *   the function returns `FFIResult::NullArgument`.
 * * All pointer arguments **must** be non‑null and point to valid memory that
 *   lives at least for the duration of the call.
 * * `args.manifest_array_ptr` must also be a valid, non‑null pointer to an
 *   array of `FFIFileManifestParentU128` with `args.manifest_len` elements.
 *   The caller is responsible for ensuring the array lives for the duration
 *   of the call.
 * * The callbacks contained in `args` (`get_keys_cb` and `get_chunks_cb`) are
 *   `unsafe extern "C"` functions; they must obey the contract described in
 *   `SerializeUncompressedDataArgsU128`.
 *
 * # Return value
 *
 * Returns an `FFIResult` indicating the outcome:
 *
 * * `FFIResult::StatusOk` – The operation succeeded and `*out_ptr` now points to a
 *   valid `FFISerializedOutputU128`.
 * * `FFIResult::NullArgument` – Either `args` or `out_ptr` (or the manifest
 *   pointer inside `args`) was null.
 * * Other error variants may be returned by the internal implementation if,
 *   for example, a callback fails or memory allocation aborts.
 */
SPRITE_SHRINK_MUST_USE
FFIResult serialize_uncompressed_data_u128(const struct SerializeUncompressedDataArgsU128 *args,
                                           FFISerializedOutputU128 **out_ptr);

/**
 * Frees the memory allocated by `serialize_uncompressed_data_u64`.
 *
 * This function is responsible for deallocating the
 * `FFISerializedOutput` struct and all the memory blocks it points
 * to. This includes the serialized manifest, data store,
 * chunk index, and sorted hashes.
 *
 * # Safety
 *
 * The `ptr` must be a non-null pointer returned from a successful
 * to `serialize_uncompressed_data_u64`.
 */
void free_serialized_output_u64(FFISerializedOutputU64 *ptr);

/**
 * Frees the memory allocated by `serialize_uncompressed_data_u128`.
 *
 * This function is responsible for deallocating the
 * `FFISerializedOutput` struct and all the memory blocks it points
 * to. This includes the serialized manifest, data store,
 * chunk index, and sorted hashes.
 *
 * # Safety
 *
 * The `ptr` must be a non-null pointer returned from a successful
 * to `serialize_uncompressed_data_u128`.
 */
void free_serialized_output_u128(FFISerializedOutputU128 *ptr);

#endif  /* FFI_LIB_SPRITE_SHRINK_H */
